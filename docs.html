<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Asynchronous HTTP Client - Clojure - Documentation</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="title" content="Asynchronous HTTP Client - Clojure - Documentation"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-05-06 23:57:58 CEST"/>
<meta name="author" content="Hubert Iwaniuk"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="stylesheet.css" />
<script type="text/javascript" src="org-info.js"></script>
<script type="text/javascript" >
<!--/*--><![CDATA[/*><!--*/
org_html_manager.set("TOC_DEPTH", "3");
org_html_manager.set("LINK_HOME", "http://neotyk.github.com");
org_html_manager.set("LINK_UP", "http://neotyk.github.com/http.async.client/");
org_html_manager.set("LOCAL_TOC", "above");
org_html_manager.set("VIEW_BUTTONS", "1");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "1");
org_html_manager.set("TOC", "1");
org_html_manager.set("VIEW", "showall");
org_html_manager.setup();  // activate after the parameters are set
/*]]>*///-->
</script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">Asynchronous HTTP Client - Clojure - Documentation</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Quick start</a>
<ul>
<li><a href="#sec-1-1">1.1 Dependency</a></li>
<li><a href="#sec-1-2">1.2 Require</a></li>
<li><a href="#sec-1-3">1.3 GETting</a></li>
</ul>
</li>
<li><a href="#sec-2">2 Detailed start</a>
<ul>
<li><a href="#sec-2-1">2.1 Work modes</a>
<ul>
<li><a href="#sec-2-1-1">2.1.1 Asynchronous operations</a></li>
<li><a href="#sec-2-1-2">2.1.2 Streaming</a></li>
<li><a href="#sec-2-1-3">2.1.3 Raw mode</a></li>
</ul>
</li>
<li><a href="#sec-2-2">2.2 HTTP methods</a>
<ul>
<li><a href="#sec-2-2-1">2.2.1 GET</a></li>
<li><a href="#sec-2-2-2">2.2.2 PUT/POST</a>
<ul>
<li><a href="#sec-2-2-2-1">2.2.2.1 Submitting body as String</a></li>
<li><a href="#sec-2-2-2-2">2.2.2.2 Submitting form parameters</a></li>
<li><a href="#sec-2-2-2-3">2.2.2.3 Submitting multipart messages</a></li>
<li><a href="#sec-2-2-2-4">2.2.2.4 Submitting body as InputStream</a></li>
<li><a href="#sec-2-2-2-5">2.2.2.5 Submitting body as File, a.k.a. zero byte copy</a></li>
</ul>
</li>
<li><a href="#sec-2-2-3">2.2.3 DELETE</a></li>
<li><a href="#sec-2-2-4">2.2.4 HEAD</a></li>
<li><a href="#sec-2-2-5">2.2.5 OPTIONS</a></li>
</ul>
</li>
<li><a href="#sec-2-3">2.3 Request options</a>
<ul>
<li><a href="#sec-2-3-1">2.3.1 :query</a></li>
<li><a href="#sec-2-3-2">2.3.2 :headers</a></li>
<li><a href="#sec-2-3-3">2.3.3 :body</a></li>
<li><a href="#sec-2-3-4">2.3.4 :cookies</a></li>
<li><a href="#sec-2-3-5">2.3.5 :proxy</a></li>
<li><a href="#sec-2-3-6">2.3.6 :auth</a></li>
<li><a href="#sec-2-3-7">2.3.7 :timeout</a></li>
</ul>
</li>
<li><a href="#sec-2-4">2.4 Streaming</a>
<ul>
<li><a href="#sec-2-4-1">2.4.1 Lazy sequence</a></li>
<li><a href="#sec-2-4-2">2.4.2 Call-back</a></li>
</ul>
</li>
<li><a href="#sec-2-5">2.5 Response handling</a>
<ul>
<li><a href="#sec-2-5-1">2.5.1 Awaiting response</a></li>
<li><a href="#sec-2-5-2">2.5.2 Reading status line</a></li>
<li><a href="#sec-2-5-3">2.5.3 Reading headers</a></li>
<li><a href="#sec-2-5-4">2.5.4 Reading cookies</a></li>
<li><a href="#sec-2-5-5">2.5.5 Reading body</a></li>
<li><a href="#sec-2-5-6">2.5.6 Reading body as string</a></li>
<li><a href="#sec-2-5-7">2.5.7 Reading error</a></li>
<li><a href="#sec-2-5-8">2.5.8 Canceling request</a></li>
<li><a href="#sec-2-5-9">2.5.9 Response predicates</a>
<ul>
<li><a href="#sec-2-5-9-1">2.5.9.1 done?</a></li>
<li><a href="#sec-2-5-9-2">2.5.9.2 failed?</a></li>
<li><a href="#sec-2-5-9-3">2.5.9.3 canceled?</a></li>
</ul>
</li>
<li><a href="#sec-2-5-10">2.5.10 Requested URL</a></li>
</ul>
</li>
<li><a href="#sec-2-6">2.6 Managing client</a>
<ul>
<li><a href="#sec-2-6-1">2.6.1 Branding</a></li>
<li><a href="#sec-2-6-2">2.6.2 Enabling HTTP compression</a></li>
<li><a href="#sec-2-6-3">2.6.3 Follow redirects</a></li>
<li><a href="#sec-2-6-4">2.6.4 Keep alive</a></li>
<li><a href="#sec-2-6-5">2.6.5 Max connections per host</a></li>
<li><a href="#sec-2-6-6">2.6.6 Max connections total count</a></li>
<li><a href="#sec-2-6-7">2.6.7 Max redirects to follow</a></li>
<li><a href="#sec-2-6-8">2.6.8 Timeouts</a></li>
<li><a href="#sec-2-6-9">2.6.9 Proxy</a></li>
<li><a href="#sec-2-6-10">2.6.10 Authentication</a></li>
<li><a href="#sec-2-6-11">2.6.11 SSL Certificates</a></li>
<li><a href="#sec-2-6-12">2.6.12 Closing <b>http.async.client</b></a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-3">3 Low level</a>
<ul>
<li><a href="#sec-3-1">3.1 Preparing request</a></li>
<li><a href="#sec-3-2">3.2 Executing request</a>
<ul>
<li><a href="#sec-3-2-1">3.2.1 Status line</a></li>
<li><a href="#sec-3-2-2">3.2.2 Headers</a></li>
<li><a href="#sec-3-2-3">3.2.3 Body part</a></li>
<li><a href="#sec-3-2-4">3.2.4 Body completed</a></li>
<li><a href="#sec-3-2-5">3.2.5 Error</a></li>
</ul>
</li>
<li><a href="#sec-3-3">3.3 Default callbacks</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Quick start</h2>
<div class="outline-text-2" id="text-1">

<p>  If you just want to use it already.
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Dependency</h3>
<div class="outline-text-3" id="text-1-1">

<p>   Declare dependency in your project.clj:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>defproject your-project <span style="color: #8b2252;">"1.0.0-SNAPSHOT"</span>
  <span style="color: #008b8b;">:description</span> <span style="color: #8b2252;">"Your project description"</span>
  <span style="color: #008b8b;">:dependencies</span> [[org.clojure/clojure <span style="color: #8b2252;">"1.4.0"</span>]
                 [http.async.client <span style="color: #8b2252;">"0.4.5"</span>]]<span style="color: #8c8c8c;">)</span>
</pre>

<p>
   Make sure that your project depends on at least 1.3.0 Clojure as
   <b>http.async.client</b> will not run in earlier versions.
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Require</h3>
<div class="outline-text-3" id="text-1-2">

<p>   Require it from your code:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">ns</span> your.ns <span style="color: #8c8c8c;">(</span><span style="color: #008b8b;">:require</span> [http.async.client <span style="color: #008b8b;">:as</span> http]<span style="color: #8c8c8c;">))</span>
</pre>

</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> GETting</h3>
<div class="outline-text-3" id="text-1-3">

<p>   To get HTTP resource:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [response <span style="color: #8c8c8c;">(</span>http/GET client <span style="color: #8b2252;">"http://github.com/neotyk/http.async.client/"</span><span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">request http resource</span>
    <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">-&gt;</span> response
        http/await     <span style="color: #b22222;">; </span><span style="color: #b22222;">wait for response to be received</span>
        http/string<span style="color: #8c8c8c;">)))</span> <span style="color: #b22222;">; </span><span style="color: #b22222;">read body of response as string</span>
</pre>

</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Detailed start</h2>
<div class="outline-text-2" id="text-2">


</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Work modes</h3>
<div class="outline-text-3" id="text-2-1">


</div>

<div id="outline-container-2-1-1" class="outline-4">
<h4 id="sec-2-1-1"><span class="section-number-4">2.1.1</span> Asynchronous operations</h4>
<div class="outline-text-4" id="text-2-1-1">

<p>    When you do:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>http/GET &lt;client&gt; url<span style="color: #8c8c8c;">)</span>
</pre>

<p>
    Result will be a map of <a href="http://clojuredocs.org/clojure_core/clojure.core/promise"><b>clojure.core/promise</b></a>s, and represents
    response.
</p>
<p>
    Following HTTP methods have been covered so far:
</p><ul>
<li><a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-GET">GET</a>
</li>
<li><a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-POST">POST</a>
</li>
<li><a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-PUT">PUT</a>
</li>
<li><a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-DELETE">DELETE</a>
</li>
<li><a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-HEAD">HEAD</a>
</li>
<li><a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-OPTIONS">OPTIONS</a>
</li>
</ul>

<p>    For detailed description see <a href="#sec-2-2">HTTP methods</a>.
</p>
<p>
    You can submit options to HTTP methods as keyworded arguments,
    like this:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>http/GET &lt;client&gt; url <span style="color: #008b8b;">:query</span> {<span style="color: #008b8b;">:key</span> <span style="color: #8b2252;">"value"</span>}<span style="color: #8c8c8c;">)</span>
</pre>

<p>
    Following options are supported:
</p><dl>
<dt><b>:query</b></dt><dd>query parameters
</dd>
<dt><b>:headers</b></dt><dd>custom headers to be sent out
</dd>
<dt><b>:body</b></dt><dd>body to be sent, allowed only with <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-PUT">PUT</a>/<a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-POST">POST</a>
</dd>
<dt><b>:cookies</b></dt><dd>cookies to be sent
</dd>
<dt><b>:proxy</b></dt><dd>proxy to be used
</dd>
</dl>

<p>    For detailed usage of options see <a href="#sec-2-3">Request options</a>.
</p>
<p>
    Response map contains following keys:
</p><dl>
<dt><b>:status</b></dt><dd>promise of lazy map of status fields
<dl>
<dt><b>:code</b></dt><dd>response code
</dd>
<dt><b>:msg</b></dt><dd>response message
</dd>
<dt><b>:protocol</b></dt><dd>protocol with version
</dd>
<dt><b>:major</b></dt><dd>major version of protocol
</dd>
<dt><b>:minor</b></dt><dd>minor version of protocol
</dd>
</dl>

</dd>
<dt><b>:headers</b></dt><dd>promise of lazy map of headers where header names are
                    keyworded, like <b>:server</b> for example
</dd>
<dt><b>:body</b></dt><dd>promise of response body, this is ByteArrayOutputStream, but you
                 have convenience functions to convert it for example to string:



<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>http/string <span style="color: #8c8c8c;">(</span>http/GET &lt;client&gt; &lt;url&gt;<span style="color: #8c8c8c;">))</span>
</pre>

</dd>
<dt><b>:done</b></dt><dd>promise that is delivered once response receiving
                 is done
</dd>
<dt><b>:error</b></dt><dd>promise, if there was an error you will find Throwable here
</dd>
</dl>

</div>

</div>

<div id="outline-container-2-1-2" class="outline-4">
<h4 id="sec-2-1-2"><span class="section-number-4">2.1.2</span> Streaming</h4>
<div class="outline-text-4" id="text-2-1-2">

<p>    For consuming HTTP streams use:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>http/stream-seq &lt;client&gt; <span style="color: #008b8b;">:get</span> url<span style="color: #8c8c8c;">)</span>
</pre>

<p>
    Response here is same as in <a href="#sec-2-1-1">Asynchronous operations</a> but <b>:body</b>
    will be lazy sequence of ByteArrayOutputStreams.
</p>
<p>
    You can still use convenience functions like <b>http/string</b> for body,
    but remember that you are dealing now with <b>seq</b>.
</p>
<p>
    For more details please see <a href="#sec-2-4-1">Lazy sequence</a>.
</p></div>

</div>

<div id="outline-container-2-1-3" class="outline-4">
<h4 id="sec-2-1-3"><span class="section-number-4">2.1.3</span> Raw mode</h4>
<div class="outline-text-4" id="text-2-1-3">

<p>    This allows you to provide callbacks that will get triggered on HTTP
    response events like:
</p><ul>
<li>received status line,
</li>
<li>received headers,
</li>
<li>received body part,
</li>
<li>completed request,
</li>
<li>handle error.
</li>
</ul>

<p>    All callbacks are expected to return tuple with first element
    been a value to be delivered for given response processing phase,
    second element is controlling execution and if you make it
    <b>:abort</b> than processing response is going to be terminated.
</p>
<p>
    For detailed information on how to use this mode please see <a href="#sec-3">Low level</a>.
</p></div>
</div>

</div>

<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> HTTP methods</h3>
<div class="outline-text-3" id="text-2-2">

<p>   HTTP methods and convenience functions to request them.
</p>
</div>

<div id="outline-container-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> GET</h4>
<div class="outline-text-4" id="text-2-2-1">

<p>    Most basic invocation of <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-GET"><b>http.async.client/GET</b></a> is only with
    <b>url</b> you want to get.
    Extended invocation includes options that can be any options
    accepted by <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.request.html#var-prepare-request"><b>http.async.client.request/prepare-request</b></a>
    [:headers :query ..].
</p>
<p>
    Simple invocation:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client <span style="color: #8b2252;">"&lt;your url&gt;"</span><span style="color: #8c8c8c;">)</span>
        status <span style="color: #8c8c8c;">(</span>http/status resp<span style="color: #8c8c8c;">)</span>
        headers <span style="color: #8c8c8c;">(</span>http/headers resp<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">println</span> <span style="color: #8c8c8c;">(</span><span style="color: #008b8b;">:code</span> status<span style="color: #8c8c8c;">))</span>
    <span style="color: #8c8c8c;">(</span>http/await resp<span style="color: #8c8c8c;">)</span>
    <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">println</span> <span style="color: #8c8c8c;">(</span>http/string resp<span style="color: #8c8c8c;">))))</span>
</pre>


<p>
    Invocation with query parameters:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client <span style="color: #8b2252;">"&lt;your url&gt;"</span> <span style="color: #008b8b;">:query</span> {<span style="color: #008b8b;">:param-name</span> <span style="color: #8b2252;">"some-value"</span>}<span style="color: #8c8c8c;">)</span>
        status <span style="color: #8c8c8c;">(</span>http/status resp<span style="color: #8c8c8c;">)</span>
        headers <span style="color: #8c8c8c;">(</span>http/headers resp<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">println</span> <span style="color: #8c8c8c;">(</span><span style="color: #008b8b;">:code</span> status<span style="color: #8c8c8c;">))</span>
    <span style="color: #8c8c8c;">(</span>http/await resp<span style="color: #8c8c8c;">)</span>
    <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">println</span> <span style="color: #8c8c8c;">(</span>http/string resp<span style="color: #8c8c8c;">))))</span>
</pre>


<p>
    Invocation with proxy:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client <span style="color: #8b2252;">"&lt;your url&gt;"</span>
                       <span style="color: #008b8b;">:query</span> {<span style="color: #008b8b;">:param-name</span> <span style="color: #8b2252;">"some-value"</span>}
                       <span style="color: #008b8b;">:proxy</span> {<span style="color: #008b8b;">:host</span> host <span style="color: #008b8b;">:port</span> port}<span style="color: #8c8c8c;">)</span>
        status <span style="color: #8c8c8c;">(</span>http/status resp<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">println</span> <span style="color: #8c8c8c;">(</span><span style="color: #008b8b;">:code</span> status<span style="color: #8c8c8c;">))</span>
    <span style="color: #8c8c8c;">(</span>http/await resp<span style="color: #8c8c8c;">)</span>
    <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">println</span> <span style="color: #8c8c8c;">(</span>http/string resp<span style="color: #8c8c8c;">))))</span>
</pre>


<p>
    Invocation with cookies:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client <span style="color: #8b2252;">"http://localhost:8123/cookie"</span>
                       <span style="color: #b22222;">;; </span><span style="color: #b22222;">Send cookie</span>
                       <span style="color: #008b8b;">:cookies</span> #{{<span style="color: #008b8b;">:domain</span> <span style="color: #8b2252;">"http://localhost:8123/"</span>
                                   <span style="color: #008b8b;">:name</span> <span style="color: #8b2252;">"sample-name"</span>
                                   <span style="color: #008b8b;">:value</span> <span style="color: #8b2252;">"sample-value"</span>
                                   <span style="color: #008b8b;">:path</span> <span style="color: #8b2252;">"/cookie"</span>
                                   <span style="color: #008b8b;">:max-age</span> 10
                                   <span style="color: #008b8b;">:secure</span> false}}<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">doseq</span> [cookie <span style="color: #8c8c8c;">(</span>http/cookies resp<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Read cookies from server response</span>
      <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">println</span> <span style="color: #8b2252;">"name:"</span> <span style="color: #8c8c8c;">(</span><span style="color: #008b8b;">:name</span> cookie<span style="color: #8c8c8c;">)</span> <span style="color: #8b2252;">", value:"</span> <span style="color: #8c8c8c;">(</span><span style="color: #008b8b;">:value</span> cookie<span style="color: #8c8c8c;">)))))</span>
</pre>

<p>
    Notice <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-cookies"><b>http.async.client/cookies</b></a> function extracts cookies from
    response headers, so to start processing it you don't need to wait
    for whole response to arrive.
</p></div>

</div>

<div id="outline-container-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> PUT/POST</h4>
<div class="outline-text-4" id="text-2-2-2">

<p>    <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-PUT"><b>http.async.client/PUT</b></a>/<a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-POST"><b>http.async.client/POST</b></a> work the same
    way as <a href="#sec-2-2-1"><b>GET</b></a> but they also accept <b>:body</b> argument.
</p>
<p>
    <b>:body</b> can be:
</p><ul>
<li>String,
</li>
<li>map, sent as form parameters,
</li>
<li>vector, sent as multipart message,
</li>
<li>input stream,
</li>
<li>java.io.File, this will be sent using zero byte copy.
</li>
</ul>


</div>

<div id="outline-container-2-2-2-1" class="outline-5">
<h5 id="sec-2-2-2-1"><span class="section-number-5">2.2.2.1</span> Submitting body as String</h5>
<div class="outline-text-5" id="text-2-2-2-1">

<p>     You can send String as body with PUT/POST:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/POST client <span style="color: #8b2252;">"&lt;your url&gt;"</span> <span style="color: #008b8b;">:body</span> <span style="color: #8b2252;">"SampleBody"</span><span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">do something with resp</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

</div>

</div>

<div id="outline-container-2-2-2-2" class="outline-5">
<h5 id="sec-2-2-2-2"><span class="section-number-5">2.2.2.2</span> Submitting form parameters</h5>
<div class="outline-text-5" id="text-2-2-2-2">

<p>     Submitting form parameters is done via body map:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/POST client <span style="color: #8b2252;">"&lt;your url&gt;"</span> <span style="color: #008b8b;">:body</span> {<span style="color: #008b8b;">:u</span> <span style="color: #8b2252;">"user"</span> <span style="color: #008b8b;">:p</span> <span style="color: #8b2252;">"s3cr3t"</span>}<span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">do something with resp</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

</div>

</div>

<div id="outline-container-2-2-2-3" class="outline-5">
<h5 id="sec-2-2-2-3"><span class="section-number-5">2.2.2.3</span> Submitting multipart messages</h5>
<div class="outline-text-5" id="text-2-2-2-3">

<p>     To send multipart messages in body use vector of maps.
     Each map describes one multipart part.
</p>
<p>
     Every map has to have <b>:type</b> key.
</p>
<p>
     Following values for <b>:type</b> are recognized:
</p><dl>
<dt>:string</dt><dd>
<p>
       Will send named string value in multipart part.
       Map spec:
</p><dl>
<dt>:name</dt><dd><b>required</b>, name of field sent in multipart part,
</dd>
<dt>:value</dt><dd><b>required</b>, value of field sent in multipart part,
</dd>
<dt>:charset</dt><dd><b>optional</b>, default <b>UTF-8</b>, charset used to encode
                     value of field set in multipart part.

</dd>
</dl>

<p>       Example of string part in use:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/POST client <span style="color: #8b2252;">"&lt;your url&gt;"</span>
                        <span style="color: #008b8b;">:body</span> [{<span style="color: #008b8b;">:type</span>    <span style="color: #008b8b;">:string</span>
                                <span style="color: #008b8b;">:name</span>    <span style="color: #8b2252;">"field-name"</span>
                                <span style="color: #008b8b;">:value</span>   <span style="color: #8b2252;">"field-value"</span>
                                <span style="color: #008b8b;">:charset</span> <span style="color: #8b2252;">"UTF-8"</span> <span style="color: #b22222;">; </span><span style="color: #b22222;">this is optional,</span>
                                        <span style="color: #b22222;">; </span><span style="color: #b22222;">and contains default value</span>
                                }]<span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">do something with resp</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

</dd>
<dt>:file</dt><dd>
<p>
       Will send named file in multipart part.
       Map spec:
</p><dl>
<dt>:name</dt><dd><b>required</b>, name of field sent in multipart part,
</dd>
<dt>:file</dt><dd><b>required</b>, java.io.File, whose contents will be
                  sent as field value,
</dd>
<dt>:mime-type</dt><dd><b>required</b>, mime-type of <i>Content-Type</i> of this
                       multipart part.
</dd>
<dt>:charset</dt><dd><b>required</b>, charset of <i>Content-Type</i> of this
                     multipart part.

</dd>
</dl>

<p>       Example of file part in use:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/POST client <span style="color: #8b2252;">"&lt;your url&gt;"</span>
                        <span style="color: #008b8b;">:body</span> [{<span style="color: #008b8b;">:type</span>      <span style="color: #008b8b;">:file</span>
                                <span style="color: #008b8b;">:name</span>      <span style="color: #8b2252;">"field-name"</span>
                                <span style="color: #008b8b;">:file</span>      <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">File.</span> <span style="color: #8b2252;">"file/to/send.txt"</span><span style="color: #8c8c8c;">)</span>
                                <span style="color: #008b8b;">:mime-type</span> <span style="color: #8b2252;">"text/plain"</span>
                                <span style="color: #008b8b;">:charset</span>   <span style="color: #8b2252;">"UTF-8"</span>}]<span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">do something with resp</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

</dd>
<dt>:bytearray</dt><dd>
<p>
       Will send named byte array part.
</p>
<p>
       Map spec:
</p><dl>
<dt>:name</dt><dd><b>required</b>, name of field sent in multipart part,
</dd>
<dt>file-name</dt><dd><b>required</b>, filename of <i>Content-Disposition</i>,
</dd>
<dt>data</dt><dd><b>required</b>, byte array containing data to sent as
                 field value,
</dd>
<dt>:mime-type</dt><dd><b>required</b>, mime-type of <i>Content-Type</i> of this
                       multipart part.
</dd>
<dt>:charset</dt><dd><b>required</b>, charset of <i>Content-Type</i> of this
                     multipart part.

</dd>
</dl>

<p>       Example of <b>:bytearray</b> in use:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/POST client <span style="color: #8b2252;">"&lt;your url&gt;"</span>
                        <span style="color: #008b8b;">:body</span> [{<span style="color: #008b8b;">:type</span>      <span style="color: #008b8b;">:bytearray</span>
                                <span style="color: #008b8b;">:name</span>      <span style="color: #8b2252;">"field-name"</span>
                                <span style="color: #008b8b;">:file-name</span> <span style="color: #8b2252;">"file-name.txt"</span>
                                <span style="color: #008b8b;">:data</span>       <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">.getBytes</span> <span style="color: #8b2252;">"contents"</span> <span style="color: #8b2252;">"UTF-8"</span><span style="color: #8c8c8c;">)</span>
                                <span style="color: #008b8b;">:mime-type</span>  <span style="color: #8b2252;">"text/plain"</span>
                                <span style="color: #008b8b;">:charset</span>    <span style="color: #8b2252;">"UTF-8"</span>}]<span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">do something with resp</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

</dd>
</dl>


<p>
     To send request with multiple multiparts <b>:body</b> vector needs to
     contain multiple maps:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/POST client <span style="color: #8b2252;">"&lt;your url&gt;"</span>
                        <span style="color: #008b8b;">:body</span> [{<span style="color: #008b8b;">:type</span>    <span style="color: #008b8b;">:string</span>
                                <span style="color: #008b8b;">:name</span>    <span style="color: #8b2252;">"field1-name"</span>
                                <span style="color: #008b8b;">:value</span>   <span style="color: #8b2252;">"field-value"</span>
                                <span style="color: #008b8b;">:charset</span> <span style="color: #8b2252;">"UTF-8"</span> <span style="color: #b22222;">; </span><span style="color: #b22222;">this is optional,</span>
                                        <span style="color: #b22222;">; </span><span style="color: #b22222;">and contains default value</span>
                                }
                               {<span style="color: #008b8b;">:type</span>      <span style="color: #008b8b;">:file</span>
                                <span style="color: #008b8b;">:name</span>      <span style="color: #8b2252;">"field2-name"</span>
                                <span style="color: #008b8b;">:file</span>      <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">File.</span> <span style="color: #8b2252;">"file/to/send.txt"</span><span style="color: #8c8c8c;">)</span>
                                <span style="color: #008b8b;">:mime-type</span> <span style="color: #8b2252;">"text/plain"</span>
                                <span style="color: #008b8b;">:charset</span>   <span style="color: #8b2252;">"UTF-8"</span>
                                }
                               {<span style="color: #008b8b;">:type</span>      <span style="color: #008b8b;">:bytearray</span>
                                <span style="color: #008b8b;">:name</span>      <span style="color: #8b2252;">"field3-name"</span>
                                <span style="color: #008b8b;">:file-name</span> <span style="color: #8b2252;">"file-name.txt"</span>
                                <span style="color: #008b8b;">:data</span>       <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">.getBytes</span> <span style="color: #8b2252;">"contents"</span> <span style="color: #8b2252;">"UTF-8"</span><span style="color: #8c8c8c;">)</span>
                                <span style="color: #008b8b;">:mime-type</span>  <span style="color: #8b2252;">"text/plain"</span>
                                <span style="color: #008b8b;">:charset</span>    <span style="color: #8b2252;">"UTF-8"</span>}]<span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">do something with resp</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

</div>

</div>

<div id="outline-container-2-2-2-4" class="outline-5">
<h5 id="sec-2-2-2-4"><span class="section-number-5">2.2.2.4</span> Submitting body as InputStream</h5>
<div class="outline-text-5" id="text-2-2-2-4">

<p>     Another method to provide body is via InputStream:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">use</span> '[clojure.java.io <span style="color: #008b8b;">:only</span> [input-stream]]<span style="color: #8c8c8c;">)</span>
<span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/PUT client <span style="color: #8b2252;">"&lt;your url&gt;"</span> <span style="color: #008b8b;">:body</span> <span style="color: #8c8c8c;">(</span>input-stream <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">.getBytes</span> <span style="color: #8b2252;">"SampleContent"</span> <span style="color: #8b2252;">"UTF-8"</span><span style="color: #8c8c8c;">)))</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">do something with resp</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

</div>

</div>

<div id="outline-container-2-2-2-5" class="outline-5">
<h5 id="sec-2-2-2-5"><span class="section-number-5">2.2.2.5</span> Submitting body as File, a.k.a. zero byte copy</h5>
<div class="outline-text-5" id="text-2-2-2-5">

<p>     To use zero byte copy future, provide a File as :body
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">import</span> '<span style="color: #8c8c8c;">(</span>java.io <span style="color: #483d8b;">File</span><span style="color: #8c8c8c;">))</span>
<span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/PUT <span style="color: #8b2252;">"&lt;your url&gt;"</span> <span style="color: #008b8b;">:body</span> <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">File.</span> <span style="color: #8b2252;">"&lt;path to file&gt;"</span><span style="color: #8c8c8c;">))</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">do something with resp</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

</div>
</div>

</div>

<div id="outline-container-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> DELETE</h4>
<div class="outline-text-4" id="text-2-2-3">

<p>    To call <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-DELETE"><b>http.async.client/DELETE</b></a> on a resource:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/DELETE <span style="color: #8b2252;">"&lt;your url&gt;"</span><span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">do something with resp</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

</div>

</div>

<div id="outline-container-2-2-4" class="outline-4">
<h4 id="sec-2-2-4"><span class="section-number-4">2.2.4</span> HEAD</h4>
<div class="outline-text-4" id="text-2-2-4">

<p>    To call <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-HEAD"><b>http.async.client/HEAD</b></a> on a resource:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/HEAD <span style="color: #8b2252;">"&lt;your url&gt;"</span><span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">do something with resp</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

</div>

</div>

<div id="outline-container-2-2-5" class="outline-4">
<h4 id="sec-2-2-5"><span class="section-number-4">2.2.5</span> OPTIONS</h4>
<div class="outline-text-4" id="text-2-2-5">

<p>    To call <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-OPTIONS"><b>http.async.client/OPTIONS</b></a> on a resource:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/OPTIONS <span style="color: #8b2252;">"&lt;your url&gt;"</span><span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">do something with resp</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

</div>
</div>

</div>

<div id="outline-container-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> Request options</h3>
<div class="outline-text-3" id="text-2-3">

<p>   Following options can be provided to requests and are defined by
   <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.request.html#var-prepare-request"><b>http.async.client.request/prepare-request</b></a>:
</p><dl>
<dt><a href="#sec-2-3-1">:query</a></dt><dd>query parameters
</dd>
<dt><a href="#sec-2-3-2">:headers</a></dt><dd>custom headers to be sent out
</dd>
<dt><a href="#sec-2-3-3">:body</a></dt><dd>body to be sent, allowed only with PUT/POST
</dd>
<dt><a href="#sec-2-3-4">:cookies</a></dt><dd>cookies to be sent
</dd>
<dt><a href="#sec-2-3-5">:proxy</a></dt><dd>proxy to be used
</dd>
<dt><a href="#sec-2-3-6">:auth</a></dt><dd>authentication map
</dd>
<dt><a href="#sec-2-3-7">:timeout</a></dt><dd>timeout configuration
</dd>
</dl>


</div>

<div id="outline-container-2-3-1" class="outline-4">
<h4 id="sec-2-3-1"><span class="section-number-4">2.3.1</span> :query</h4>
<div class="outline-text-4" id="text-2-3-1">

<p>    Query parameters is a map of keywords and their values. You use
    it like so:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url <span style="color: #008b8b;">:query</span> {<span style="color: #008b8b;">:key1</span> <span style="color: #8b2252;">"value1"</span> <span style="color: #008b8b;">:key2</span> <span style="color: #8b2252;">"value2"</span>}<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span>http/await resp<span style="color: #8c8c8c;">)</span>
    <span style="color: #8c8c8c;">(</span>http/string resp<span style="color: #8c8c8c;">)))</span>
</pre>

</div>

</div>

<div id="outline-container-2-3-2" class="outline-4">
<h4 id="sec-2-3-2"><span class="section-number-4">2.3.2</span> :headers</h4>
<div class="outline-text-4" id="text-2-3-2">

<p>    Custom headers can be submitted same way as <a href="#sec-2-3-1">:query</a>:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url <span style="color: #008b8b;">:headers</span> {<span style="color: #008b8b;">:header-name1</span> <span style="color: #8b2252;">"value1"</span>
                                            <span style="color: #008b8b;">:header-name2</span> <span style="color: #8b2252;">"value2"</span>}<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span>http/await resp<span style="color: #8c8c8c;">)</span>
    <span style="color: #8c8c8c;">(</span>http/string resp<span style="color: #8c8c8c;">)))</span>
</pre>

</div>

</div>

<div id="outline-container-2-3-3" class="outline-4">
<h4 id="sec-2-3-3"><span class="section-number-4">2.3.3</span> :body</h4>
<div class="outline-text-4" id="text-2-3-3">

<p>    Body can be provided with a message only with <a href="#sec-2-2-2">PUT/POST</a>, it
    doesn't make sense to have body with other <a href="#sec-2-2">HTTP methods</a>.
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/PUT client url <span style="color: #008b8b;">:body</span> <span style="color: #8b2252;">"sample body"</span><span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span>http/await resp<span style="color: #8c8c8c;">)</span>
    <span style="color: #8c8c8c;">(</span>http/string resp<span style="color: #8c8c8c;">)))</span>
</pre>

<p>
    <b>:body</b> can be:
</p><ul>
<li>String,
</li>
<li>map, sent as form parameters,
</li>
<li>vector, sent as multipart message,
</li>
<li>input stream,
</li>
<li>java.io.File, this will be sent using zero byte copy.
</li>
</ul>


<p>
    Please see <a href="#sec-2-2-2">PUT/POST</a> for more documentation.
</p></div>

</div>

<div id="outline-container-2-3-4" class="outline-4">
<h4 id="sec-2-3-4"><span class="section-number-4">2.3.4</span> :cookies</h4>
<div class="outline-text-4" id="text-2-3-4">

<p>    Cookies can be provided to request as follows:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client <span style="color: #8b2252;">"http://localhost:8123/cookie"</span>
                       <span style="color: #008b8b;">:cookies</span> #{{<span style="color: #008b8b;">:domain</span> <span style="color: #8b2252;">"http://localhost:8123/"</span>
                                   <span style="color: #008b8b;">:name</span> <span style="color: #8b2252;">"sample-name"</span>
                                   <span style="color: #008b8b;">:value</span> <span style="color: #8b2252;">"sample-value"</span>
                                   <span style="color: #008b8b;">:path</span> <span style="color: #8b2252;">"/cookie"</span>
                                   <span style="color: #008b8b;">:max-age</span> 10
                                   <span style="color: #008b8b;">:secure</span> false}}<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span>http/await resp<span style="color: #8c8c8c;">)</span>
    <span style="color: #8c8c8c;">(</span>http/string resp<span style="color: #8c8c8c;">)))</span>
</pre>

<p>
    <b>:cookies</b> option takes sequence of cookie maps, in this example
    a hash set.
    Cookie map consist of:
</p><dl>
<dt><b>:domain</b></dt><dd>Domain that cookie has been installed
</dd>
<dt><b>:name</b></dt><dd>Cookie name
</dd>
<dt><b>:value</b></dt><dd>Cookie value, note that there is no additional
                  processing so you should encode it yourself if
                  needed.
</dd>
<dt><b>:path</b></dt><dd>Path on with cookie has been installed
</dd>
<dt><b>:max-age</b></dt><dd>Max age that cookie was configured to live
</dd>
<dt><b>:secure</b></dt><dd>If cookie is secure cookie
</dd>
</dl>


<p>
    Cookie reading is described in <a href="#sec-2-5-4">Reading cookies</a>.
</p></div>

</div>

<div id="outline-container-2-3-5" class="outline-4">
<h4 id="sec-2-3-5"><span class="section-number-4">2.3.5</span> :proxy</h4>
<div class="outline-text-4" id="text-2-3-5">

<p>    Proxy can be configured per request basis as follows:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url <span style="color: #008b8b;">:proxy</span> {<span style="color: #008b8b;">:host</span> h <span style="color: #008b8b;">:port</span> p}<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span>http/await resp<span style="color: #8c8c8c;">)</span>
    <span style="color: #8c8c8c;">(</span>http/string resp<span style="color: #8c8c8c;">)))</span>
</pre>

<p>
    Proxy expects a map with following keys:
</p><dl>
<dt><b>:host</b></dt><dd>proxy host
</dd>
<dt><b>:port</b></dt><dd>proxy port
</dd>
<dt><b>:protocol</b></dt><dd><i>optional</i> protocol to communicate with proxy.
                     Can be <b>:http</b> (default) or <b>:https</b>.
</dd>
<dt><b>:user</b></dt><dd><i>optional</i> user name to use for proxy authentication.
                 Must be provided with :password.
</dd>
<dt><b>:password</b></dt><dd><i>optional</i> password to use for proxy
                     authentication.
                     Must be provided with :user.
</dd>
</dl>

</div>

</div>

<div id="outline-container-2-3-6" class="outline-4">
<h4 id="sec-2-3-6"><span class="section-number-4">2.3.6</span> :auth</h4>
<div class="outline-text-4" id="text-2-3-6">

<p>    Authentication can be configured per request basis.
    For now BASIC and DIGEST methods are supported.
</p>
<p>
    Basic method is default, so you don't have to specify it:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url <span style="color: #008b8b;">:auth</span> {<span style="color: #008b8b;">:user</span> u <span style="color: #008b8b;">:password</span> p}<span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">Check if response is not 401 or so and process response</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

<p>
    Though you can:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url <span style="color: #008b8b;">:auth</span> {<span style="color: #008b8b;">:type</span> <span style="color: #008b8b;">:basic</span> <span style="color: #008b8b;">:user</span> u <span style="color: #008b8b;">:password</span> p}<span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">Check if response is not 401 or so and process response</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

<p>
    And for digest method you will need realm as well:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url
                       <span style="color: #008b8b;">:auth</span> {<span style="color: #008b8b;">:type</span> <span style="color: #008b8b;">:digest</span> <span style="color: #008b8b;">:user</span> u <span style="color: #008b8b;">:password</span> p <span style="color: #008b8b;">:realm</span> r}<span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">Check if response is not 401 or so and process response</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

<p>
    Controlling preemptive authentication behavior is also possible:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>]
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url <span style="color: #008b8b;">:auth</span> {<span style="color: #008b8b;">:user</span> u <span style="color: #008b8b;">:password</span> p <span style="color: #008b8b;">:preemptive</span> true}<span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">process response</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

</div>

</div>

<div id="outline-container-2-3-7" class="outline-4">
<h4 id="sec-2-3-7"><span class="section-number-4">2.3.7</span> :timeout</h4>
<div class="outline-text-4" id="text-2-3-7">

<p>    Response timeout can be configured per request as well.
    Timeout value is time in milliseconds in which response has to be
    received.
    There is special value <b>-1</b> that indicates infinite timeout.
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url <span style="color: #008b8b;">:timeout</span> -1<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span>http/await resp<span style="color: #8c8c8c;">)</span>
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">process response</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

<p>
    Sample above will wait until response is fully received, as long
    as it takes (-1 timeout).
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url <span style="color: #008b8b;">:timeout</span> 100<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span>http/await resp<span style="color: #8c8c8c;">)</span>
    <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">if</span> <span style="color: #8c8c8c;">(</span>http/failed? resp<span style="color: #8c8c8c;">)</span>
      <span style="color: #b22222;">;; </span><span style="color: #b22222;">did not get response in configured timeout</span>
      <span style="color: #b22222;">;; </span><span style="color: #b22222;">process response</span>
      <span style="color: #8c8c8c;">)))</span>
</pre>

<p>
    Example above configures timeout to 100ms, so <b>await</b> will only
    wait for 100ms, after that response is done.
    Which doesn't necessarily mean that it was delivered to client
    successfully, because it was restricted by timeout, that is why
    example contains check if response has failed.
</p></div>
</div>

</div>

<div id="outline-container-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> Streaming</h3>
<div class="outline-text-3" id="text-2-4">

<p>   HTTP Stream is response with chunked content encoding.
   Those streams might not be meant to ever finish, see twitter.com
   streams, so collecting those responses as a whole is impossible,
   they should be processed by response parts (chunks) as they are
   been received.
</p>
<p>
   Two ways of consuming a HTTP Stream are supported:
</p><ul>
<li><a href="#sec-2-4-1">Lazy sequence</a>
</li>
<li><a href="#sec-2-4-2">Call-back</a>
</li>
</ul>


</div>

<div id="outline-container-2-4-1" class="outline-4">
<h4 id="sec-2-4-1"><span class="section-number-4">2.4.1</span> Lazy sequence</h4>
<div class="outline-text-4" id="text-2-4-1">

<p>    You can get HTTP Stream as lazy sequence of it's body.
    This is very convenient method as <b>seq</b> is native type of Clojure
    so you can apply all mapping, filtering and any other standard
    function that you like to it.
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/stream-seq client <span style="color: #008b8b;">:get</span> url<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">doseq</span> [s <span style="color: #8c8c8c;">(</span>http/string resp<span style="color: #8c8c8c;">)</span>]
      <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">println</span> s<span style="color: #8c8c8c;">))))</span>
</pre>

<p>
    <b>stream-seq</b> arguments:
</p><dl>
<dt>http method</dt><dd>any of supported methods can be used, though it
                     makes sense only to use <b>:get</b>, <b>:put</b> and
                     <b>:post</b>
</dd>
<dt>url</dt><dd>URL of HTTP resource
</dd>
<dt>options</dt><dd>same as normal <a href="#sec-2-3">Request options</a>.
</dd>
</dl>


<p>
    It is important to understand that seqs returned by <b>body</b> or
    <b>string</b> (which in turn calls body) are backed by queue.
    One of consequences of it is that once you consumed some body
    parts they will not be available anymore.
    Let's see code speak for itself.
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/stream-seq <span style="color: #008b8b;">:get</span> url<span style="color: #8c8c8c;">)</span>]
  <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">println</span> <span style="color: #8b2252;">"1: "</span> <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">first</span> <span style="color: #8c8c8c;">(</span>http/string resp<span style="color: #8c8c8c;">)))</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">println</span> <span style="color: #8b2252;">"2: "</span> <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">first</span> <span style="color: #8c8c8c;">(</span>http/string resp<span style="color: #8c8c8c;">))))</span>
</pre>

<p>
    This code will print following:
</p><pre class="example">
1: part1
2: part2
</pre>

<p>    Assuming that part1 is first chunk and part2 is second.
</p>
<p>
    Second consequence of been directly backed by queue is that you
    can have multiple consumers of same response and non of them will
    get same body part.
</p>
<p>
    And finally this implementation is not holding to it's head.
</p></div>

</div>

<div id="outline-container-2-4-2" class="outline-4">
<h4 id="sec-2-4-2"><span class="section-number-4">2.4.2</span> Call-back</h4>
<div class="outline-text-4" id="text-2-4-2">

<p>    Consuming HTTP Stream with call-back is quite straight forward with
    <b>http.async.client</b>. You will need to know what HTTP Method you will call,
    what URL and provide a call back function to handle body parts been
    received.
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [parts <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">ref</span> #{}<span style="color: #8c8c8c;">)</span>
        resp <span style="color: #8c8c8c;">(</span>http/request-stream client <span style="color: #008b8b;">:get</span> url
                                  <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">fn</span> [state body]
                                    <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">dosync</span> <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">alter</span> parts conj <span style="color: #8c8c8c;">(</span>string body<span style="color: #8c8c8c;">)))</span>
                                    [body <span style="color: #008b8b;">:continue</span>]<span style="color: #8c8c8c;">))</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">do something to @parts</span>
    <span style="color: #8c8c8c;">))</span>
</pre>


<p>
    Few notes on implementing body part callback:
</p><ul>
<li>state is a <b>map</b> with <b>:status</b> and <b>:headers</b> as promises, at
   stage when you get called for body part, both of them should be in
   place already, though it is advised to use convenience methods to
   read them, see <a href="#sec-2-5-2">Reading status line</a> and <a href="#sec-2-5-3">Reading headers</a>,
</li>
<li>call-back has to follow guidelines described in <a href="#sec-3-2-3">Body part</a>,
</li>
<li>some streams are not meant to be finished, in that case don't
   collect body parts, as for sure you will run out of available
   resources,
</li>
<li>try not to do any heavy lifting in this callback, better send it
   to agent.
</li>
</ul>

</div>
</div>

</div>

<div id="outline-container-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> Response handling</h3>
<div class="outline-text-3" id="text-2-5">

<p>   <b>http.async.client</b> exposes some convenience functions for
   response handling.
</p>
</div>

<div id="outline-container-2-5-1" class="outline-4">
<h4 id="sec-2-5-1"><span class="section-number-4">2.5.1</span> Awaiting response</h4>
<div class="outline-text-4" id="text-2-5-1">

<p>    If you call any of <a href="#sec-2-1-1">Asynchronous operations</a>, <a href="#sec-2-1-2">Streaming</a> or <a href="#sec-2-1-3">Raw mode</a>
    you actually asynchronously execute HTTP request.
    Some times you might need to wait for response processing to be
    done before proceeding, in order to do so you call
    <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-await"><b>http.async.client/await</b></a>.
    It takes only one argument, that is response and returns once
    receiving has finished.
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span>http/await resp<span style="color: #8c8c8c;">)))</span>
</pre>

<p>
    Sample above will behave like synchronous HTTP operation.
    For convenience it returns same response so you can use it
    further, for example like that:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span>http/string <span style="color: #8c8c8c;">(</span>http/await resp<span style="color: #8c8c8c;">))))</span>
</pre>

</div>

</div>

<div id="outline-container-2-5-2" class="outline-4">
<h4 id="sec-2-5-2"><span class="section-number-4">2.5.2</span> Reading status line</h4>
<div class="outline-text-4" id="text-2-5-2">

<p>    <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-status"><b>http.async.client/status</b></a> returns status lazy map of response.
    It will wait until HTTP Status has been received.
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp   <span style="color: #8c8c8c;">(</span>http/GET client url<span style="color: #8c8c8c;">)</span>
        status <span style="color: #8c8c8c;">(</span>http/status resp<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span><span style="color: #008b8b;">:code</span> status<span style="color: #8c8c8c;">)))</span>
</pre>

<p>
    Sample above will return HTTP response status code, notice that
    after this returns headers and body, might not been delivered
    yet.
</p></div>

</div>

<div id="outline-container-2-5-3" class="outline-4">
<h4 id="sec-2-5-3"><span class="section-number-4">2.5.3</span> Reading headers</h4>
<div class="outline-text-4" id="text-2-5-3">

<p>    <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-headers"><b>http.async.client/headers</b></a> returns headers lazy map of response.
    It will wait until HTTP Headers are received.
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp    <span style="color: #8c8c8c;">(</span>http/GET client url<span style="color: #8c8c8c;">)</span>
        headers <span style="color: #8c8c8c;">(</span>http/headers resp<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span><span style="color: #008b8b;">:server</span> headers<span style="color: #8c8c8c;">)))</span>
</pre>

<p>
    Again, like in case of status, body might not have been delivered
    yet after this returns.
</p></div>

</div>

<div id="outline-container-2-5-4" class="outline-4">
<h4 id="sec-2-5-4"><span class="section-number-4">2.5.4</span> Reading cookies</h4>
<div class="outline-text-4" id="text-2-5-4">

<p>    <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-cookies"><b>http.async.client/cookies</b></a> returns seq of maps representing
    cookies.
    It will wait until HTTP Headers are received.
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp    <span style="color: #8c8c8c;">(</span>http/GET client url<span style="color: #8c8c8c;">)</span>
        cookies <span style="color: #8c8c8c;">(</span>http/cookies resp<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">map</span> <span style="color: #008b8b;">:name</span> cookies<span style="color: #8c8c8c;">)))</span>
</pre>

<p>
    Sample above will return sequence of cookie names that server has
    set.
</p></div>

</div>

<div id="outline-container-2-5-5" class="outline-4">
<h4 id="sec-2-5-5"><span class="section-number-4">2.5.5</span> Reading body</h4>
<div class="outline-text-4" id="text-2-5-5">

<p>    <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-body"><b>http.async.client/body</b></a> returns either ByteArrayOutputStream or
    seq of it, depending if you used <a href="#sec-2-1-1">Asynchronous operations</a> or
    <a href="#sec-2-1-2">Streaming</a> respectively.
    It will <b>not</b> wait for response to be finished, it will return as
    soon as first chunk of HTTP response body is received.
</p></div>

</div>

<div id="outline-container-2-5-6" class="outline-4">
<h4 id="sec-2-5-6"><span class="section-number-4">2.5.6</span> Reading body as string</h4>
<div class="outline-text-4" id="text-2-5-6">

<p>    <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-string"><b>http.async.client/string</b></a> returns either string or seq of
    strings, again depending if you used <a href="#sec-2-1-1">Asynchronous operations</a> or
    <a href="#sec-2-1-2">Streaming</a> respectively.
    It will <b>not</b> wait for response to be finished, it will return as
    soon as first chunk of HTTP response body is received.
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span>http/string <span style="color: #8c8c8c;">(</span>http/await resp<span style="color: #8c8c8c;">))))</span>
</pre>

<p>
    Sample above will return string of response body.
    <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-string"><b>http.async.client/string</b></a> is lazy so you can use it in case of
    streams as well.
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp    <span style="color: #8c8c8c;">(</span>http/stream-seq client <span style="color: #008b8b;">:get</span> url<span style="color: #8c8c8c;">)</span>
        strings <span style="color: #8c8c8c;">(</span>http/string resp<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">doseq</span> [part strings]
      <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">println</span> part<span style="color: #8c8c8c;">))))</span>
</pre>

<p>
    Sample above will print parts as they are received, and will
    return once response receiving is finished.
</p></div>

</div>

<div id="outline-container-2-5-7" class="outline-4">
<h4 id="sec-2-5-7"><span class="section-number-4">2.5.7</span> Reading error</h4>
<div class="outline-text-4" id="text-2-5-7">

<p>    <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-error"><b>http.async.client/error</b></a> will return Throwable that was cause of
    request failure iff request failed, else <b>nil</b>.
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span>http/await resp<span style="color: #8c8c8c;">)</span>
    <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">when-let</span> [err <span style="color: #8c8c8c;">(</span>http/error resp<span style="color: #8c8c8c;">)</span>]
      <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">println</span> <span style="color: #8b2252;">"failed processing request: "</span> err<span style="color: #8c8c8c;">))))</span>
</pre>

</div>

</div>

<div id="outline-container-2-5-8" class="outline-4">
<h4 id="sec-2-5-8"><span class="section-number-4">2.5.8</span> Canceling request</h4>
<div class="outline-text-4" id="text-2-5-8">

<p>    At any given time of processing HTTP Response you can <b>cancel</b> it
    by calling <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-cancel"><b>http.async.client/cancel</b></a>.
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span>http/cancel resp<span style="color: #8c8c8c;">)))</span>
</pre>

<p>
    Please see <b>canceling-request</b> test.
</p></div>

</div>

<div id="outline-container-2-5-9" class="outline-4">
<h4 id="sec-2-5-9"><span class="section-number-4">2.5.9</span> Response predicates</h4>
<div class="outline-text-4" id="text-2-5-9">

<p>    You can also check status of request.
</p>
</div>

<div id="outline-container-2-5-9-1" class="outline-5">
<h5 id="sec-2-5-9-1"><span class="section-number-5">2.5.9.1</span> done?</h5>
<div class="outline-text-5" id="text-2-5-9-1">

<p>     <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-done?"><b>http.async.client/done?</b></a> will tell you if response processing
     has finished:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">Create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">when-not</span> <span style="color: #8c8c8c;">(</span>http/done? resp<span style="color: #8c8c8c;">)</span>
      <span style="color: #8c8c8c;">(</span>http/await resp<span style="color: #8c8c8c;">)</span>
      <span style="color: #8c8c8c;">(</span>http/done? resp<span style="color: #8c8c8c;">))))</span>
</pre>

<p>
     Sample above will check if response was finished, if not - will
     wait for it and return true as a result of call to done?.
</p></div>

</div>

<div id="outline-container-2-5-9-2" class="outline-5">
<h5 id="sec-2-5-9-2"><span class="section-number-5">2.5.9.2</span> failed?</h5>
<div class="outline-text-5" id="text-2-5-9-2">

<p>     <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-failed?"><b>http.async.client/failed?</b></a> will return true iff request has
     failed. If this return true you can <a href="#sec-2-5-7">read error</a>.
</p></div>

</div>

<div id="outline-container-2-5-9-3" class="outline-5">
<h5 id="sec-2-5-9-3"><span class="section-number-5">2.5.9.3</span> canceled?</h5>
<div class="outline-text-5" id="text-2-5-9-3">

<p>     <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-canceled?"><b>http.async.client/canceled?</b></a> will return true iff request has
     been <a href="#sec-2-5-8">canceled</a>, else false is return.
</p></div>
</div>

</div>

<div id="outline-container-2-5-10" class="outline-4">
<h4 id="sec-2-5-10"><span class="section-number-4">2.5.10</span> Requested URL</h4>
<div class="outline-text-4" id="text-2-5-10">

<p>    If you need to get URL of response at hand, there are two
    associations in it that you will find useful:
</p><dl>
<dt>:url</dt><dd>encoded url,
</dd>
<dt>:raw-url</dt><dd>not encoded url.
</dd>
</dl>


<p>
    And two convenience functions:
</p><ul>
<li><a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-url"><b>http.async.client/url</b></a>,
</li>
<li><a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-raw-url"><b>http.async.client/raw-url</b></a>.
</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-2-6" class="outline-3">
<h3 id="sec-2-6"><span class="section-number-3">2.6</span> Managing client</h3>
<div class="outline-text-3" id="text-2-6">


</div>

<div id="outline-container-2-6-1" class="outline-4">
<h4 id="sec-2-6-1"><span class="section-number-4">2.6.1</span> Branding</h4>
<div class="outline-text-4" id="text-2-6-1">

<p>    <b>http.async.client</b> can be configured with User-Agent. To do so
    you can use <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-create-client"><b>http.async.client/create-client</b></a> and remember to
    close created client yourself, best is to use it within macro
    like with-open, though make sure that body of it will wait for
    whole response to finish.
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client <span style="color: #008b8b;">:user-agent</span> <span style="color: #8b2252;">"Your User Agent/1.0"</span><span style="color: #8c8c8c;">)</span>]
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url<span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">do stuff with resp</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

</div>

</div>

<div id="outline-container-2-6-2" class="outline-4">
<h4 id="sec-2-6-2"><span class="section-number-4">2.6.2</span> Enabling HTTP compression</h4>
<div class="outline-text-4" id="text-2-6-2">

<p>    <b>http.async.client</b> can be configured to allow, or not, HTTP
    compression.
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client <span style="color: #008b8b;">:compression-enabled</span> true<span style="color: #8c8c8c;">)</span>]
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url<span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">do stuff with resp</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

</div>

</div>

<div id="outline-container-2-6-3" class="outline-4">
<h4 id="sec-2-6-3"><span class="section-number-4">2.6.3</span> Follow redirects</h4>
<div class="outline-text-4" id="text-2-6-3">

<p>    Enabling HTTP redirects following.
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client  <span style="color: #8c8c8c;">(</span>http/create-client {<span style="color: #008b8b;">:follow-redirects</span> true}<span style="color: #8c8c8c;">)</span>]
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url<span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">do stuff with resp</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

</div>

</div>

<div id="outline-container-2-6-4" class="outline-4">
<h4 id="sec-2-6-4"><span class="section-number-4">2.6.4</span> Keep alive</h4>
<div class="outline-text-4" id="text-2-6-4">

<p>    Keep Alive is enabled by default. This implies using pool for
    connections.
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client <span style="color: #008b8b;">:keep-alive</span> true<span style="color: #8c8c8c;">)</span>]
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url<span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">do stuff with resp</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

</div>

</div>

<div id="outline-container-2-6-5" class="outline-4">
<h4 id="sec-2-6-5"><span class="section-number-4">2.6.5</span> Max connections per host</h4>
<div class="outline-text-4" id="text-2-6-5">

<p>    Maximum number of connections to be cached per host.
    Above this number connections will still be created but will not
    be kept alive.
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client <span style="color: #008b8b;">:max-conns-per-host</span> 10<span style="color: #8c8c8c;">)</span>]
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url<span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">do stuff with resp</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

</div>

</div>

<div id="outline-container-2-6-6" class="outline-4">
<h4 id="sec-2-6-6"><span class="section-number-4">2.6.6</span> Max connections total count</h4>
<div class="outline-text-4" id="text-2-6-6">

<p>    Maximum number of total connections opened, submitting new
    request while all allowed connections are active, will result in
    rejection.
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client <span style="color: #008b8b;">:max-conns-total</span> 100<span style="color: #8c8c8c;">)</span>]
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url<span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">do stuff with resp</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

</div>

</div>

<div id="outline-container-2-6-7" class="outline-4">
<h4 id="sec-2-6-7"><span class="section-number-4">2.6.7</span> Max redirects to follow</h4>
<div class="outline-text-4" id="text-2-6-7">

<p>    Maximum number of redirects to follow.
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client <span style="color: #008b8b;">:max-redirects</span> 3<span style="color: #8c8c8c;">)</span>]
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url<span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">do stuff with resp</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

</div>

</div>

<div id="outline-container-2-6-8" class="outline-4">
<h4 id="sec-2-6-8"><span class="section-number-4">2.6.8</span> Timeouts</h4>
<div class="outline-text-4" id="text-2-6-8">

<p>    With <b>http.async.client</b> apart from per connection <a href="#sec-2-3-7">:timeout</a> you
    can globally configure <b>connection</b>, <b>request</b> and <b>idle</b>
    timeouts. All timeout values are in milliseconds and magic value
    <b>-1</b> is interpreted as infinite wait.
    <b>idle</b> connection in pool timeout works only on connections in
    pool, connections idle, for configured time, in pool will be
    closed.
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client <span style="color: #008b8b;">:connection-timeout</span> 10
                                       <span style="color: #008b8b;">:request-timeout</span> 1000
                                       <span style="color: #008b8b;">:idle-in-pool-timeout</span> 100<span style="color: #8c8c8c;">)</span>]
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url<span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">request processing</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

<p>
    Example above will timeout connection if it was not established
    in 10ms, request if it was not received in 1sec, or connection
    when it was idling in pool for more than 100ms.
</p></div>

</div>

<div id="outline-container-2-6-9" class="outline-4">
<h4 id="sec-2-6-9"><span class="section-number-4">2.6.9</span> Proxy</h4>
<div class="outline-text-4" id="text-2-6-9">

<p>    Client can be also configured with global HTTP Proxy settings.
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client <span style="color: #008b8b;">:proxy</span> {<span style="color: #008b8b;">:host</span> h <span style="color: #008b8b;">:port</span> p}<span style="color: #8c8c8c;">)</span>]
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url<span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">do stuff with resp</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

<p>
    Proxy expects a map with following keys:
</p><dl>
<dt><b>:host</b></dt><dd>proxy host
</dd>
<dt><b>:port</b></dt><dd>proxy port
</dd>
<dt><b>:protocol</b></dt><dd><i>optional</i> protocol to communicate with proxy.
                     Can be <b>:http</b> (default) or <b>:https</b>.
</dd>
<dt><b>:user</b></dt><dd><i>optional</i> user name to use for proxy authentication.
                 Must be provided with :password.
</dd>
<dt><b>:password</b></dt><dd><i>optional</i> password to use for proxy
                     authentication.
                     Must be provided with :user.
</dd>
</dl>

</div>

</div>

<div id="outline-container-2-6-10" class="outline-4">
<h4 id="sec-2-6-10"><span class="section-number-4">2.6.10</span> Authentication</h4>
<div class="outline-text-4" id="text-2-6-10">

<p>    Default authentication realm to be used globally can be
    configured.
    For now BASIC and DIGEST methods are supported.
</p>
<p>
    Basic method is default, so you don't have to specify it:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client <span style="color: #008b8b;">:auth</span> {<span style="color: #008b8b;">:user</span> u <span style="color: #008b8b;">:password</span> p}<span style="color: #8c8c8c;">)</span>] 
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url<span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">Check if response is not 401 or so and process response</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

<p>
    Though you can:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client <span style="color: #008b8b;">:auth</span> {<span style="color: #008b8b;">:type</span> <span style="color: #008b8b;">:basic</span> <span style="color: #008b8b;">:user</span> u <span style="color: #008b8b;">:password</span> p}<span style="color: #8c8c8c;">)</span>]
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url<span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">Check if response is not 401 or so and process response</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

<p>
    And for digest method you will need realm as well:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client <span style="color: #008b8b;">:auth</span> {<span style="color: #008b8b;">:type</span> <span style="color: #008b8b;">:digest</span> <span style="color: #008b8b;">:user</span> u <span style="color: #008b8b;">:password</span> p <span style="color: #008b8b;">:realm</span> r}<span style="color: #8c8c8c;">)</span>]
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url<span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">Check if response is not 401 or so and process response</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

<p>
    Preemptive authentication can be enabled or disabled globally per client:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client <span style="color: #008b8b;">:auth</span> {<span style="color: #008b8b;">:type</span> <span style="color: #008b8b;">:basic</span> <span style="color: #008b8b;">:user</span> u <span style="color: #008b8b;">:passowrd</span> p <span style="color: #008b8b;">:preemptive</span> true}<span style="color: #8c8c8c;">)</span>]
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url<span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">process response</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

</div>

</div>

<div id="outline-container-2-6-11" class="outline-4">
<h4 id="sec-2-6-11"><span class="section-number-4">2.6.11</span> SSL Certificates</h4>
<div class="outline-text-4" id="text-2-6-11">

<p>    Since v0.4.2 it is possible to use SSL certificates with client.
</p>
<p>
    For client to use SSL you need to provide it with <b>ssl-context</b>.
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">require</span> [http.async.client.cert <span style="color: #008b8b;">:as</span> cert]<span style="color: #8c8c8c;">)</span>
<span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [ctx <span style="color: #8c8c8c;">(</span>cert/ssl-context <span style="color: #008b8b;">:keystore-file</span> ks-file
                            <span style="color: #008b8b;">:keystore-password</span> password
                            <span style="color: #008b8b;">:certificate-file</span> cert-file
                            <span style="color: #008b8b;">:certificate-alias</span> other-cert-alias<span style="color: #8c8c8c;">)</span>]
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client <span style="color: #008b8b;">:ssl-context</span> ctx<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url<span style="color: #8c8c8c;">)</span>]
      <span style="color: #b22222;">;; </span><span style="color: #b22222;">process response</span>
      <span style="color: #8c8c8c;">)))</span>
</pre>


<p>
    For more documentation please consult docstring of
    <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.cert.html#var-ssl-context"><b>http.async.client.cert/ssl-context</b></a> and tests.
</p>
</div>

</div>

<div id="outline-container-2-6-12" class="outline-4">
<h4 id="sec-2-6-12"><span class="section-number-4">2.6.12</span> Closing <b>http.async.client</b></h4>
<div class="outline-text-4" id="text-2-6-12">

<p>    Whenever you've created <b>http.async.client</b> via
    <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-create-client"><b>http.async.client/create-client</b></a> you will need to close it.
    To do so you call <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-close"><b>http.async.client/close</b></a>.
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>]
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">try</span>
    <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [resp <span style="color: #8c8c8c;">(</span>http/GET client url<span style="color: #8c8c8c;">)</span>]
      <span style="color: #b22222;">;; </span><span style="color: #b22222;">process response</span>
      <span style="color: #8c8c8c;">)</span>
    <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">finally</span>
     <span style="color: #8c8c8c;">(</span>http/close client<span style="color: #8c8c8c;">))))</span>
</pre>

</div>
</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Low level</h2>
<div class="outline-text-2" id="text-3">

<p>  This is lowest level access to <b>http.async.client</b>.
  Mechanics here is based on asynchronous call-backs.
  It provides default set of callbacks and functions to create and
  execute requests.
</p>
</div>

<div id="outline-container-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Preparing request</h3>
<div class="outline-text-3" id="text-3-1">

<p>   <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.request.html#var-prepare-request"><b>http.async.client.request/prepare-request</b></a> is responsible for
   request preparation, like the name suggests.
   It takes following arguments:
</p><ul>
<li>HTTP Method like <b>:get</b> <b>:head</b>
</li>
<li><b>url</b> that you want to call
</li>
<li>and <b>options</b>, a keyworded map described already in <a href="#sec-2-3">Request options</a>.
    Sample:



<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>]
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [req <span style="color: #8c8c8c;">(</span>request/prepare-request client
                                     <span style="color: #008b8b;">:get</span> <span style="color: #8b2252;">"http://google.com"</span>
                                     <span style="color: #008b8b;">:headers</span> {<span style="color: #008b8b;">:my-header</span> <span style="color: #8b2252;">"value"</span>}<span style="color: #8c8c8c;">)</span>]
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">now you have request, next thing to do would be to execute it</span>
    <span style="color: #8c8c8c;">))</span>
</pre>

</li>
</ul>

</div>

</div>

<div id="outline-container-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Executing request</h3>
<div class="outline-text-3" id="text-3-2">

<p>   <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.request.html#var-execute-request"><b>http.async.client.request/execute-request</b></a> returns same map of promises
   as <a href="#sec-2-1-1">Asynchronous operations</a>.
   Its arguments are: request to be executed (result of <a href="#sec-3-1">Preparing request</a>) and <b>options</b> as keyworded map consisting of call-backs.
   Following <b>options</b> keys are recognized:
</p><dl>
<dt><b>:status</b></dt><dd><a href="#sec-3-2-1">Status line</a>
</dd>
<dt><b>:headers</b></dt><dd><a href="#sec-3-2-2">Headers</a>
</dd>
<dt><b>:part</b></dt><dd><a href="#sec-3-2-3">Body part</a>
</dd>
<dt><b>:completed</b></dt><dd><a href="#sec-3-2-4">Body completed</a>
</dd>
<dt><b>:error</b></dt><dd><a href="#sec-3-2-5">Error</a>
</dd>
</dl>

<p>   All callbacks take response map as first argument and callback
   specific argument if any.
   Callbacks are expected to return tuple of <b>result</b> and <b>action</b>:
</p><dl>
<dt><b>result</b></dt><dd>will be delivered to respective promise in response
                 map
</dd>
<dt><b>action</b></dt><dd>if its value is <b>:abort</b> than response processing
                 will be aborted, anything else here will result in
                 continuation.
</dd>
</dl>


</div>

<div id="outline-container-3-2-1" class="outline-4">
<h4 id="sec-3-2-1"><span class="section-number-4">3.2.1</span> Status line</h4>
<div class="outline-text-4" id="text-3-2-1">

<p>    Status line callback gets called after status line has been
    received with arguments:
</p><ul>
<li>response map
</li>
<li>Status map has following keys:
<ul>
<li><b>:code</b> status code (200, 404, ..)
</li>
<li><b>:msg</b> status message ("OK", ..)
</li>
<li><b>:protocol</b> protocol with version ("HTTP/1.1")
</li>
<li><b>:major</b> major protocol version (1)
</li>
<li><b>:minor</b> minor protocol version (0, 1)
</li>
</ul>

</li>
</ul>


<p>
    Sample code to illustrate how to use status callback:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [request <span style="color: #8c8c8c;">(</span>request/prepare-request client <span style="color: #008b8b;">:get</span> <span style="color: #8b2252;">"http://example.com"</span><span style="color: #8c8c8c;">)</span> <span style="color: #b22222;">; </span><span style="color: #b22222;">create request</span>
        status <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">promise</span><span style="color: #8c8c8c;">)</span>                <span style="color: #b22222;">; </span><span style="color: #b22222;">status promise that will be delivered by callback</span>
        response <span style="color: #8c8c8c;">(</span>request/execute-request
                  client request        <span style="color: #b22222;">; </span><span style="color: #b22222;">execute *request*</span>
                  <span style="color: #008b8b;">:status</span>               <span style="color: #b22222;">; </span><span style="color: #b22222;">status callback</span>
                  <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">fn</span> [res st]          <span style="color: #b22222;">; </span><span style="color: #b22222;">*res* is response map, same as one returned by *execute-request*</span>
                                        <span style="color: #b22222;">; </span><span style="color: #b22222;">*st* is status map, as described above</span>
                    <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">deliver</span> status st<span style="color: #8c8c8c;">)</span> <span style="color: #b22222;">; </span><span style="color: #b22222;">deliver status promise</span>
                    [st <span style="color: #008b8b;">:abort</span>]<span style="color: #8c8c8c;">))</span>]      <span style="color: #b22222;">; </span><span style="color: #b22222;">return status to be delivered to response map and abort further processing of response.</span>
    <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">println</span> @status<span style="color: #8c8c8c;">)))</span>                 <span style="color: #b22222;">; </span><span style="color: #b22222;">await status to be delivered and print it.</span>
</pre>

</div>

</div>

<div id="outline-container-3-2-2" class="outline-4">
<h4 id="sec-3-2-2"><span class="section-number-4">3.2.2</span> Headers</h4>
<div class="outline-text-4" id="text-3-2-2">

<p>    Headers callback gets called after headers have been received
    with arguments:
</p><ul>
<li>response map
</li>
<li>lazy map of headers. Keys in that map are <b>(keyword       (.toLowerCase &lt;header name&gt;))</b>, so "Server" headers is
      <b>:server</b> and so on.
</li>
</ul>


<p>
    Sample code to illustrate how to use headers callback:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [request <span style="color: #8c8c8c;">(</span>request/prepare-request client <span style="color: #008b8b;">:get</span> <span style="color: #8b2252;">"http://example.com"</span><span style="color: #8c8c8c;">)</span> <span style="color: #b22222;">; </span><span style="color: #b22222;">create request</span>
        headers <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">promise</span><span style="color: #8c8c8c;">)</span>               <span style="color: #b22222;">; </span><span style="color: #b22222;">headers promise that will be delivered by callback</span>
        response <span style="color: #8c8c8c;">(</span>request/execute-request
                  client request        <span style="color: #b22222;">; </span><span style="color: #b22222;">execute *request*</span>
                  <span style="color: #008b8b;">:header</span>               <span style="color: #b22222;">; </span><span style="color: #b22222;">header callback</span>
                  <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">fn</span> [res hds]         <span style="color: #b22222;">; </span><span style="color: #b22222;">*res* is response map, same as one returned by *execute-request*</span>
                                        <span style="color: #b22222;">; </span><span style="color: #b22222;">*hds* is headers map, as described above</span>
                    <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">deliver</span> headers st<span style="color: #8c8c8c;">)</span> <span style="color: #b22222;">; </span><span style="color: #b22222;">deliver headers promise</span>
                    [hds <span style="color: #008b8b;">:abort</span>]<span style="color: #8c8c8c;">))</span>]     <span style="color: #b22222;">; </span><span style="color: #b22222;">return headers to be delivered to response map and abort further processing of response.</span>
    <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">println</span> @headers<span style="color: #8c8c8c;">)))</span>
</pre>

</div>

</div>

<div id="outline-container-3-2-3" class="outline-4">
<h4 id="sec-3-2-3"><span class="section-number-4">3.2.3</span> Body part</h4>
<div class="outline-text-4" id="text-3-2-3">

<p>    Body part callback gets called after each part of body has been
    received with arguments:
</p><ul>
<li>response map
</li>
<li>ByteArrayOutputStream that contains body part received.
</li>
</ul>


<p>
    Following code sample will show how to count number of body parts
    received:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [cnt <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">atom</span> 0<span style="color: #8c8c8c;">)</span>                    <span style="color: #b22222;">; </span><span style="color: #b22222;">body parts counter</span>
        request <span style="color: #8c8c8c;">(</span>request/prepare-request <span style="color: #008b8b;">:get</span> <span style="color: #8b2252;">"http://localhost:8123/stream"</span><span style="color: #8c8c8c;">)</span> <span style="color: #b22222;">; </span><span style="color: #b22222;">create request</span>
        resp <span style="color: #8c8c8c;">(</span>execute-request
              *client* request          <span style="color: #b22222;">; </span><span style="color: #b22222;">execute *request*</span>
              <span style="color: #008b8b;">:part</span>                     <span style="color: #b22222;">; </span><span style="color: #b22222;">body part callback</span>
              <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">fn</span> [_ p]                 <span style="color: #b22222;">; </span><span style="color: #b22222;">ignore response map,</span>
                                        <span style="color: #b22222;">; </span><span style="color: #b22222;">*p* is body part</span>
                <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">swap!</span> cnt inc<span style="color: #8c8c8c;">)</span>         <span style="color: #b22222;">; </span><span style="color: #b22222;">increment body part counter</span>
                [p <span style="color: #008b8b;">:continue</span>]<span style="color: #8c8c8c;">))</span>]        <span style="color: #b22222;">; </span><span style="color: #b22222;">return part to be delivered to response map and continue processing of response.</span>
    <span style="color: #8c8c8c;">(</span>http/await resp<span style="color: #8c8c8c;">)</span>                   <span style="color: #b22222;">; </span><span style="color: #b22222;">wait for response to finish</span>
    <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">println</span> @cnt<span style="color: #8c8c8c;">)))</span>                    <span style="color: #b22222;">; </span><span style="color: #b22222;">print body parts counter</span>
</pre>


<p>
    Next sample will collect body parts:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [parts <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">atom</span> #{}<span style="color: #8c8c8c;">)</span>                <span style="color: #b22222;">; </span><span style="color: #b22222;">body parts collector</span>
        request <span style="color: #8c8c8c;">(</span>request/prepare-request <span style="color: #008b8b;">:get</span> <span style="color: #8b2252;">"http://localhost:8123/stream"</span><span style="color: #8c8c8c;">)</span> <span style="color: #b22222;">; </span><span style="color: #b22222;">create request</span>
        resp <span style="color: #8c8c8c;">(</span>execute-request
              *client* request          <span style="color: #b22222;">; </span><span style="color: #b22222;">execute *request*</span>
              <span style="color: #008b8b;">:part</span>                     <span style="color: #b22222;">; </span><span style="color: #b22222;">body part callback</span>
              <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">fn</span> [_ <span style="color: #228b22;">^ByteArrayOutputStream</span> p] <span style="color: #b22222;">; </span><span style="color: #b22222;">ignore response map,</span>
                                        <span style="color: #b22222;">; </span><span style="color: #b22222;">*p* is body part</span>
                <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [p <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">.toString</span> part <span style="color: #8b2252;">"UTF-8"</span><span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">extract text</span>
                  <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">swap!</span> parts conj p<span style="color: #8c8c8c;">)</span>  <span style="color: #b22222;">; </span><span style="color: #b22222;">collect body part</span>
                  [p <span style="color: #008b8b;">:continue</span>]<span style="color: #8c8c8c;">)))</span>]     <span style="color: #b22222;">; </span><span style="color: #b22222;">return part to be delivered to response map and continue processing of response.</span>
    <span style="color: #8c8c8c;">(</span>http/await resp<span style="color: #8c8c8c;">)</span>                   <span style="color: #b22222;">; </span><span style="color: #b22222;">wait for response to finish</span>
    <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">println</span> @parts<span style="color: #8c8c8c;">)))</span>                  <span style="color: #b22222;">; </span><span style="color: #b22222;">print collected body parts</span>
</pre>

</div>

</div>

<div id="outline-container-3-2-4" class="outline-4">
<h4 id="sec-3-2-4"><span class="section-number-4">3.2.4</span> Body completed</h4>
<div class="outline-text-4" id="text-3-2-4">

<p>    This callback gets called when receiving of response body has
    finished with only one argument, i.e. response map.
</p>
<p>
    Following snippet shows how to measure execution time:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [request <span style="color: #8c8c8c;">(</span>request/prepare-request <span style="color: #008b8b;">:get</span> <span style="color: #8b2252;">"http://localhost:8123/"</span><span style="color: #8c8c8c;">)</span> <span style="color: #b22222;">; </span><span style="color: #b22222;">create request</span>
        finished <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">promise</span><span style="color: #8c8c8c;">)</span>               <span style="color: #b22222;">; </span><span style="color: #b22222;">execution time will be stored here</span>
        start <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">System/currentTimeMillis</span><span style="color: #8c8c8c;">)</span> <span style="color: #b22222;">; </span><span style="color: #b22222;">start time</span>
        resp <span style="color: #8c8c8c;">(</span>execute-request
              *client* request           <span style="color: #b22222;">; </span><span style="color: #b22222;">execute *request*</span>
              <span style="color: #008b8b;">:completed</span>                 <span style="color: #b22222;">; </span><span style="color: #b22222;">completed callback</span>
              <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">fn</span> [_]                    <span style="color: #b22222;">; </span><span style="color: #b22222;">ignore response map,</span>
                <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">deliver</span> finished        <span style="color: #b22222;">; </span><span style="color: #b22222;">deliver execution time</span>
                         <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">-</span> <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">System/currentTimeMillis</span><span style="color: #8c8c8c;">)</span> start<span style="color: #8c8c8c;">))))</span>]
    <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">println</span> @finished<span style="color: #8c8c8c;">)))</span>                <span style="color: #b22222;">; </span><span style="color: #b22222;">print execution time</span>
</pre>


<p>
    You have to be aware of fact that <b>:completed</b> callback is called
    only on successful response. Next snippet will show that
    <b>:completed</b> callback is not called when request errors:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [request <span style="color: #8c8c8c;">(</span>request/prepare-request <span style="color: #008b8b;">:get</span> <span style="color: #8b2252;">"http://not-existing-host/"</span><span style="color: #8c8c8c;">)</span> <span style="color: #b22222;">; </span><span style="color: #b22222;">create request</span>
        finished <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">promise</span><span style="color: #8c8c8c;">)</span>               <span style="color: #b22222;">; </span><span style="color: #b22222;">would get delivered if :completed callback would get executed</span>
        resp <span style="color: #8c8c8c;">(</span>execute-request
              *client* request           <span style="color: #b22222;">; </span><span style="color: #b22222;">execute *request*</span>
              <span style="color: #008b8b;">:completed</span>                 <span style="color: #b22222;">; </span><span style="color: #b22222;">completed callback, will not fire in this example</span>
              <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">fn</span> [_]                    <span style="color: #b22222;">; </span><span style="color: #b22222;">ignore response map,</span>
                <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">deliver</span> finished true<span style="color: #8c8c8c;">)))</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">deliver finished promise</span>
    <span style="color: #8c8c8c;">(</span>http/await resp<span style="color: #8c8c8c;">)</span>                    <span style="color: #b22222;">; </span><span style="color: #b22222;">wait for response</span>
    <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">false?</span> <span style="color: #8c8c8c;">(</span>realized? finished<span style="color: #8c8c8c;">))))</span>      <span style="color: #b22222;">; </span><span style="color: #b22222;">finished promise never got delivered</span>
</pre>

</div>

</div>

<div id="outline-container-3-2-5" class="outline-4">
<h4 id="sec-3-2-5"><span class="section-number-4">3.2.5</span> Error</h4>
<div class="outline-text-4" id="text-3-2-5">

<p>    Error callback gets called when error while processing has been
    encountered with arguments
</p><ul>
<li>response map
</li>
<li><b>Throwable</b> that was a cause of failure
</li>
</ul>


<p>
    Next code snippet shows error callback in use:
</p>


<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">with-open</span> [client <span style="color: #8c8c8c;">(</span>http/create-client<span style="color: #8c8c8c;">)</span>] <span style="color: #b22222;">; </span><span style="color: #b22222;">create client</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #483d8b;">let</span> [request <span style="color: #8c8c8c;">(</span>request/prepare-request <span style="color: #008b8b;">:get</span> <span style="color: #8b2252;">"http://not-existing-host/"</span><span style="color: #8c8c8c;">)</span> <span style="color: #b22222;">; </span><span style="color: #b22222;">create request</span>
        errored <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">promise</span><span style="color: #8c8c8c;">)</span>                <span style="color: #b22222;">; </span><span style="color: #b22222;">will store exception</span>
        resp <span style="color: #8c8c8c;">(</span>execute-request
              *client* request           <span style="color: #b22222;">; </span><span style="color: #b22222;">execute *request*</span>
              <span style="color: #008b8b;">:error</span>                     <span style="color: #b22222;">; </span><span style="color: #b22222;">error callback</span>
              <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">fn</span> [_ e]                  <span style="color: #b22222;">; </span><span style="color: #b22222;">ignore response map, *e* is exception</span>
                <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">deliver</span> errored e<span style="color: #8c8c8c;">)))</span>]   <span style="color: #b22222;">; </span><span style="color: #b22222;">deliver errored promise</span>
    <span style="color: #8c8c8c;">(</span>http/await resp<span style="color: #8c8c8c;">)</span>                    <span style="color: #b22222;">; </span><span style="color: #b22222;">wait for response</span>
    <span style="color: #8c8c8c;">(</span><span style="color: #a0522d;">println</span> @errored<span style="color: #8c8c8c;">)))</span>                 <span style="color: #b22222;">; </span><span style="color: #b22222;">print exception from callback</span>
</pre>

</div>
</div>

</div>

<div id="outline-container-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Default callbacks</h3>
<div class="outline-text-3" id="text-3-3">

<p>   <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.request.html#var-*default-callbacks*"><b>http.async.client.request/*default-callbacks*</b></a> is a map of
   default callbacks. This will allow you to easy change only few
   callbacks and reuse default for the rest.
</p>
<p>
   Please look at source of <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-stream-seq"><b>http.async.client/stream-seq</b></a> to see
   how to do it.
</p>


<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-28022940-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</div>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2012-05-06 23:57:58 CEST</p>
<p class="author">Author: Hubert Iwaniuk</p>
<p class="creator">Org version 7.8.03 with Emacs version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
