<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>Asynchronous HTTP Client - Clojure - Documentation</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-02-05 16:38:43 CET"/>
<meta name="author" content="Hubert Iwaniuk"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="stylesheet.css" />
<script type="text/javascript" src="org-info.js"></script>
<script type="text/javascript" >
<!--/*--><![CDATA[/*><!--*/
org_html_manager.set("TOC_DEPTH", "2");
org_html_manager.set("LINK_HOME", "http://neotyk.github.com");
org_html_manager.set("LINK_UP", "http://neotyk.github.com/http.async.client/");
org_html_manager.set("LOCAL_TOC", "above");
org_html_manager.set("VIEW_BUTTONS", "1");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "1");
org_html_manager.set("TOC", "1");
org_html_manager.set("VIEW", "showall");
org_html_manager.setup();  // activate after the parameters are set
/*]]>*///-->
</script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">Asynchronous HTTP Client - Clojure - Documentation</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Quick start </a>
<ul>
<li><a href="#sec-1-1">1.1 Dependency </a></li>
<li><a href="#sec-1-2">1.2 Require </a></li>
<li><a href="#sec-1-3">1.3 GETting </a></li>
</ul>
</li>
<li><a href="#sec-2">2 Detailed start </a>
<ul>
<li><a href="#sec-2-1">2.1 Work modes </a>
<ul>
<li><a href="#sec-2-1-1">2.1.1 Asynchronous operations </a></li>
<li><a href="#sec-2-1-2">2.1.2 Streaming </a></li>
<li><a href="#sec-2-1-3">2.1.3 Raw mode </a></li>
</ul>
</li>
<li><a href="#sec-2-2">2.2 HTTP methods </a>
<ul>
<li><a href="#sec-2-2-1">2.2.1 GET </a></li>
<li><a href="#sec-2-2-2">2.2.2 PUT/POST </a>
<ul>
<li><a href="#sec-2-2-2-1">2.2.2.1 Submitting body as String </a></li>
<li><a href="#sec-2-2-2-2">2.2.2.2 Submitting form parameters </a></li>
<li><a href="#sec-2-2-2-3">2.2.2.3 Submitting body as InputStream </a></li>
<li><a href="#sec-2-2-2-4">2.2.2.4 Submitting body as File, a.k.a. zero byte copy </a></li>
</ul>
</li>
<li><a href="#sec-2-2-3">2.2.3 DELETE </a></li>
<li><a href="#sec-2-2-4">2.2.4 HEAD </a></li>
<li><a href="#sec-2-2-5">2.2.5 OPTIONS </a></li>
</ul>
</li>
<li><a href="#sec-2-3">2.3 Request options </a>
<ul>
<li><a href="#sec-2-3-1">2.3.1 :query </a></li>
<li><a href="#sec-2-3-2">2.3.2 :headers </a></li>
<li><a href="#sec-2-3-3">2.3.3 :body </a></li>
<li><a href="#sec-2-3-4">2.3.4 :cookies </a></li>
<li><a href="#sec-2-3-5">2.3.5 :proxy </a></li>
<li><a href="#sec-2-3-6">2.3.6 :auth </a></li>
<li><a href="#sec-2-3-7">2.3.7 :timeout </a></li>
</ul>
</li>
<li><a href="#sec-2-4">2.4 Streaming </a>
<ul>
<li><a href="#sec-2-4-1">2.4.1 Lazy sequence </a></li>
<li><a href="#sec-2-4-2">2.4.2 Call-back </a></li>
</ul>
</li>
<li><a href="#sec-2-5">2.5 Response handling </a>
<ul>
<li><a href="#sec-2-5-1">2.5.1 Awaiting response </a></li>
<li><a href="#sec-2-5-2">2.5.2 Reading status line </a></li>
<li><a href="#sec-2-5-3">2.5.3 Reading headers </a></li>
<li><a href="#sec-2-5-4">2.5.4 Reading cookies </a></li>
<li><a href="#sec-2-5-5">2.5.5 Reading body </a></li>
<li><a href="#sec-2-5-6">2.5.6 Reading body as string </a></li>
<li><a href="#sec-2-5-7">2.5.7 Reading error </a></li>
<li><a href="#sec-2-5-8">2.5.8 Canceling request </a></li>
<li><a href="#sec-2-5-9">2.5.9 Response predicates </a>
<ul>
<li><a href="#sec-2-5-9-1">2.5.9.1 done? </a></li>
<li><a href="#sec-2-5-9-2">2.5.9.2 failed? </a></li>
<li><a href="#sec-2-5-9-3">2.5.9.3 canceled? </a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-2-6">2.6 Managing client </a>
<ul>
<li><a href="#sec-2-6-1">2.6.1 Branding </a></li>
<li><a href="#sec-2-6-2">2.6.2 Enabling HTTP compression </a></li>
<li><a href="#sec-2-6-3">2.6.3 Follow redirects </a></li>
<li><a href="#sec-2-6-4">2.6.4 Keep alive </a></li>
<li><a href="#sec-2-6-5">2.6.5 Max connections per host </a></li>
<li><a href="#sec-2-6-6">2.6.6 Max connections total count </a></li>
<li><a href="#sec-2-6-7">2.6.7 Max redirects to follow </a></li>
<li><a href="#sec-2-6-8">2.6.8 Timeouts </a></li>
<li><a href="#sec-2-6-9">2.6.9 Proxy </a></li>
<li><a href="#sec-2-6-10">2.6.10 Authentication </a></li>
<li><a href="#sec-2-6-11">2.6.11 Closing <b>http.async.client</b> </a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-3">3 Low level </a>
<ul>
<li><a href="#sec-3-1">3.1 Preparing request </a></li>
<li><a href="#sec-3-2">3.2 Executing request </a>
<ul>
<li><a href="#sec-3-2-1">3.2.1 Status line </a></li>
<li><a href="#sec-3-2-2">3.2.2 Headers </a></li>
<li><a href="#sec-3-2-3">3.2.3 Body part </a></li>
<li><a href="#sec-3-2-4">3.2.4 Body completed </a></li>
<li><a href="#sec-3-2-5">3.2.5 Error </a></li>
</ul>
</li>
<li><a href="#sec-3-3">3.3 Default callbacks </a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Quick start </h2>
<div class="outline-text-2" id="text-1">

<p>  If you just want to use it already.
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Dependency </h3>
<div class="outline-text-3" id="text-1-1">

<p>   Declare dependency in your project.clj:
</p>


<pre class="example">(defproject your-project "1.0.0-SNAPSHOT"
  :description "Your project description"
  :dependencies [[org.clojure/clojure "1.3.0"]
                 [http.async.client "0.4.1"]])
</pre>



<p>
   Make sure that your project depends on at least 1.3.0 Clojure as
   <b>http.async.client</b> will not run in earlier versions.
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Require </h3>
<div class="outline-text-3" id="text-1-2">

<p>   Require it from your code:
</p>


<pre class="example">(ns your.ns (:require [http.async.client :as client]))
</pre>



</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> GETting </h3>
<div class="outline-text-3" id="text-1-3">

<p>   To get HTTP resource:
</p>


<pre class="example">(with-open [client (client/create-client)] ;; Create client
  ;; request http resource
  (let [response (client/GET client "http://github.com/neotyk/http.async.client/")]
    ;; wait for response to be received
    (client/await response)
    ;; read body of response as string
    (client/string response)))
</pre>



</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Detailed start </h2>
<div class="outline-text-2" id="text-2">


</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Work modes </h3>
<div class="outline-text-3" id="text-2-1">


</div>

<div id="outline-container-2-1-1" class="outline-4">
<h4 id="sec-2-1-1"><span class="section-number-4">2.1.1</span> Asynchronous operations </h4>
<div class="outline-text-4" id="text-2-1-1">

<p>    When you do:
</p>


<pre class="example">(client/GET &lt;client&gt; url)
</pre>



<p>
    Result will be a map of <a href="http://clojuredocs.org/clojure_core/clojure.core/promise"><b>clojure.core/promise</b></a>s, and represents
    response.
</p>
<p>
    Following HTTP methods have been covered so far:
</p><ul>
<li><a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-GET">GET</a>
</li>
<li><a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-POST">POST</a>
</li>
<li><a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-PUT">PUT</a>
</li>
<li><a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-DELETE">DELETE</a>
</li>
<li><a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-HEAD">HEAD</a>
</li>
<li><a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-OPTIONS">OPTIONS</a>
</li>
</ul>

<p>    For detailed description see <a href="#sec-2-2">HTTP methods</a>.
</p>
<p>
    You can submit options to HTTP methods as keyworded arguments,
    like this:
</p>


<pre class="example">(client/GET &lt;client&gt; url :query {:key "value"})
</pre>



<p>
    Following options are supported:
</p><dl>
<dt><b>:query</b></dt><dd>query parameters
</dd>
<dt><b>:headers</b></dt><dd>custom headers to be sent out
</dd>
<dt><b>:body</b></dt><dd>body to be sent, allowed only with <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-PUT">PUT</a>/<a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-POST">POST</a>
</dd>
<dt><b>:cookies</b></dt><dd>cookies to be sent
</dd>
<dt><b>:proxy</b></dt><dd>proxy to be used
</dd>
</dl>

<p>    For detailed usage of options see <a href="#sec-2-3">Request options</a>.
</p>
<p>
    Response map contains following keys:
</p><dl>
<dt><b>:status</b></dt><dd>promise of lazy map of status fields
<dl>
<dt><b>:code</b></dt><dd>response code
</dd>
<dt><b>:msg</b></dt><dd>response message
</dd>
<dt><b>:protocol</b></dt><dd>protocol with version
</dd>
<dt><b>:major</b></dt><dd>major version of protocol
</dd>
<dt><b>:minor</b></dt><dd>minor version of protocol
</dd>
</dl>

</dd>
<dt><b>:headers</b></dt><dd>promise of lazy map of headers where header names are
                    keyworded, like <b>:server</b> for example
</dd>
<dt><b>:body</b></dt><dd>promise of response body, this is ByteArrayOutputStream, but you
                 have convenience functions to convert it for example to string:



<pre class="example">(client/string (client/GET &lt;client&gt; &lt;url&gt;))
</pre>



</dd>
<dt><b>:done</b></dt><dd>promise that is delivered once response receiving
                 is done
</dd>
<dt><b>:error</b></dt><dd>promise, if there was an error you will find Throwable here
</dd>
</dl>

</div>

</div>

<div id="outline-container-2-1-2" class="outline-4">
<h4 id="sec-2-1-2"><span class="section-number-4">2.1.2</span> Streaming </h4>
<div class="outline-text-4" id="text-2-1-2">

<p>    For consuming HTTP streams use:
</p>


<pre class="example">(client/stream-seq &lt;client&gt; :get url)
</pre>



<p>
    Response here is same as in <a href="#sec-2-1-1">Asynchronous operations</a> but <b>:body</b>
    will be lazy sequence of ByteArrayOutputStreams.
</p>
<p>
    You can still use convenience functions like <b>client/string</b> for body,
    but remember that you are dealing now with <b>seq</b>.
</p>
<p>
    For more details please see <a href="#sec-2-4-1">Lazy sequence</a>.
</p></div>

</div>

<div id="outline-container-2-1-3" class="outline-4">
<h4 id="sec-2-1-3"><span class="section-number-4">2.1.3</span> Raw mode </h4>
<div class="outline-text-4" id="text-2-1-3">

<p>    This allows you to provide callbacks that will get triggered on HTTP
    response events like:
</p><ul>
<li>received status line,
</li>
<li>received headers,
</li>
<li>received body part,
</li>
<li>completed request,
</li>
<li>handle error.
</li>
</ul>

<p>    All callbacks are expected to return tuple with first element
    been a value to be delivered for given response processing phase,
    second element is controlling execution and if you make it
    <b>:abort</b> than processing response is going to be terminated.
</p>
<p>
    For detailed information on how to use this mode please see <a href="#sec-3">Low level</a>.
</p></div>
</div>

</div>

<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> HTTP methods </h3>
<div class="outline-text-3" id="text-2-2">

<p>   HTTP methods and convenience functions to request them.
</p>
</div>

<div id="outline-container-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> GET </h4>
<div class="outline-text-4" id="text-2-2-1">

<p>    Most basic invocation of <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-GET"><b>http.async.client/GET</b></a> is only with
    <b>url</b> you want to get.
    Extended invocation includes options that can be any options
    accepted by <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.request.html#var-prepare-request"><b>http.async.client.request/prepare-request</b></a>
    [:headers :query ..].
</p>
<p>
    Simple invocation:
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp (client/GET client "&lt;your url&gt;")
        status (client/status resp)
        headers (client/headers resp)]
    (println (:code status))
    (client/await resp)
    (println (client/string resp))))
</pre>




<p>
    Invocation with query parameters:
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp (client/GET client "&lt;your url&gt;" :query {:param-name "some-value"})
        status (client/status resp)
        headers (client/headers resp)]
    (println (:code status))
    (client/await resp)
    (println (client/string resp))))
</pre>




<p>
    Invocation with proxy:
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp (client/GET client "&lt;your url&gt;"
                         :query {:param-name "some-value"}
                         :proxy {:host host :port port})
        status (client/status resp)]
    (println (:code status))
    (client/await resp)
    (println (client/string resp))))
</pre>




<p>
    Invocation with cookies:
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp (client/GET client "http://localhost:8123/cookie"
                         ;; Send cookie
                         :cookies #{{:domain "http://localhost:8123/"
                                     :name "sample-name"
                                     :value "sample-value"
                                     :path "/cookie"
                                     :max-age 10
                                     :secure false}})]
    (doseq [cookie (client/cookies resp)] ; Read cookies from server response
      (println "name:" (:name cookie) ", value:" (:value cookie)))))
</pre>



<p>
    Notice <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-cookies"><b>http.async.client/cookies</b></a> function extracts cookies from
    response headers, so to start processing it you don't need to wait
    for whole response to arrive.
</p></div>

</div>

<div id="outline-container-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> PUT/POST </h4>
<div class="outline-text-4" id="text-2-2-2">

<p>    <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-PUT"><b>http.async.client/PUT</b></a>/<a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-POST"><b>http.async.client/POST</b></a> work the same
    way as <a href="#sec-2-2-1"><b>GET</b></a> but they also accept <b>:body</b> argument.
</p>
<p>
    <b>:body</b> can be:
</p><ul>
<li>String
</li>
<li>map, for easy form data submissions
</li>
<li>InputStream for any content
</li>
<li>File for zero byte copy
</li>
</ul>


</div>

<div id="outline-container-2-2-2-1" class="outline-5">
<h5 id="sec-2-2-2-1"><span class="section-number-5">2.2.2.1</span> Submitting body as String </h5>
<div class="outline-text-5" id="text-2-2-2-1">

<p>     You can send String as body with PUT/POST:
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp (client/POST client "&lt;your url&gt;" :body "SampleBody")]
                                        ; do something with resp
    ))
</pre>



</div>

</div>

<div id="outline-container-2-2-2-2" class="outline-5">
<h5 id="sec-2-2-2-2"><span class="section-number-5">2.2.2.2</span> Submitting form parameters </h5>
<div class="outline-text-5" id="text-2-2-2-2">

<p>     Submitting parameters via body map:
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp (client/POST client "&lt;your url&gt;" :body {:u "user" :p "s3cr3t"})]
                                        ; do something with resp
    ))
</pre>



</div>

</div>

<div id="outline-container-2-2-2-3" class="outline-5">
<h5 id="sec-2-2-2-3"><span class="section-number-5">2.2.2.3</span> Submitting body as InputStream </h5>
<div class="outline-text-5" id="text-2-2-2-3">

<p>     Another method to provide body is via InputStream:
</p>


<pre class="example">(use '[clojure.java.io :only [input-stream]])
(with-open [client (client/create-client)] ; Create client
  (let [resp (client/PUT client "&lt;your url&gt;" :body (input-stream (.getBytes "SampleContent" "UTF-8")))]
                                        ; do something with resp
    ))
</pre>



</div>

</div>

<div id="outline-container-2-2-2-4" class="outline-5">
<h5 id="sec-2-2-2-4"><span class="section-number-5">2.2.2.4</span> Submitting body as File, a.k.a. zero byte copy </h5>
<div class="outline-text-5" id="text-2-2-2-4">

<p>     To use zero byte copy future, provide a File as :body
</p>


<pre class="example">(import '(java.io File))
(with-open [client (client/create-client)] ; Create client
  (let [resp (client/PUT "&lt;your url&gt;" :body (File. "&lt;path to file&gt;"))]
    ; do something with resp
    ))
</pre>



</div>
</div>

</div>

<div id="outline-container-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> DELETE </h4>
<div class="outline-text-4" id="text-2-2-3">

<p>    To call <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-DELETE"><b>http.async.client/DELETE</b></a> on a resource:
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp (client/DELETE "&lt;your url&gt;")]
                                        ; do something with resp
    ))
</pre>



</div>

</div>

<div id="outline-container-2-2-4" class="outline-4">
<h4 id="sec-2-2-4"><span class="section-number-4">2.2.4</span> HEAD </h4>
<div class="outline-text-4" id="text-2-2-4">

<p>    To call <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-HEAD"><b>http.async.client/HEAD</b></a> on a resource:
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp (client/HEAD "&lt;your url&gt;")]
                                        ; do something with resp
    ))
</pre>



</div>

</div>

<div id="outline-container-2-2-5" class="outline-4">
<h4 id="sec-2-2-5"><span class="section-number-4">2.2.5</span> OPTIONS </h4>
<div class="outline-text-4" id="text-2-2-5">

<p>    To call <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-OPTIONS"><b>http.async.client/OPTIONS</b></a> on a resource:
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp (client/OPTIONS "&lt;your url&gt;")]
                                        ; do something with resp
    ))
</pre>



</div>
</div>

</div>

<div id="outline-container-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> Request options </h3>
<div class="outline-text-3" id="text-2-3">

<p>   Following options can be provided to requests and are defined by
   <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.request.html#var-prepare-request"><b>http.async.client.request/prepare-request</b></a>:
</p><dl>
<dt><a href="#sec-2-3-1">:query</a></dt><dd>query parameters
</dd>
<dt><a href="#sec-2-3-2">:headers</a></dt><dd>custom headers to be sent out
</dd>
<dt><a href="#sec-2-3-3">:body</a></dt><dd>body to be sent, allowed only with PUT/POST
</dd>
<dt><a href="#sec-2-3-4">:cookies</a></dt><dd>cookies to be sent
</dd>
<dt><a href="#sec-2-3-5">:proxy</a></dt><dd>proxy to be used
</dd>
<dt><a href="#sec-2-3-6">:auth</a></dt><dd>authentication map
</dd>
<dt><a href="#sec-2-3-7">:timeout</a></dt><dd>timeout configuration
</dd>
</dl>


</div>

<div id="outline-container-2-3-1" class="outline-4">
<h4 id="sec-2-3-1"><span class="section-number-4">2.3.1</span> :query </h4>
<div class="outline-text-4" id="text-2-3-1">

<p>    Query parameters is a map of keywords and their values. You use
    it like so:
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp (client/GET client url :query {:key1 "value1" :key2 "value2"})]
    (client/await resp)
    (client/string resp)))
</pre>



</div>

</div>

<div id="outline-container-2-3-2" class="outline-4">
<h4 id="sec-2-3-2"><span class="section-number-4">2.3.2</span> :headers </h4>
<div class="outline-text-4" id="text-2-3-2">

<p>    Custom headers can be submitted same way as <a href="#sec-2-3-1">:query</a>:
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp (client/GET client url :headers {:header-name1 "value1"
                                       :header-name2 "value2"})]
    (client/await resp)
    (client/string resp)))
</pre>



</div>

</div>

<div id="outline-container-2-3-3" class="outline-4">
<h4 id="sec-2-3-3"><span class="section-number-4">2.3.3</span> :body </h4>
<div class="outline-text-4" id="text-2-3-3">

<p>    Body can be provided with a message only with <a href="#sec-2-2-2">PUT/POST</a>, it
    doesn't make sense to have body with other <a href="#sec-2-2">HTTP methods</a>.
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp (client/PUT client url :body "sample body")]
    (client/await resp)
    (client/string resp)))
</pre>



<p>
    <b>:body</b> can be String, form parameters (that is map), input stream or
    java.io.File, please see <a href="#sec-2-2-2">PUT/POST</a> for more documentation.
</p></div>

</div>

<div id="outline-container-2-3-4" class="outline-4">
<h4 id="sec-2-3-4"><span class="section-number-4">2.3.4</span> :cookies </h4>
<div class="outline-text-4" id="text-2-3-4">

<p>    Cookies can be provided to request as follows:
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp (client/GET client "http://localhost:8123/cookie"
                         :cookies #{{:domain "http://localhost:8123/"
                                     :name "sample-name"
                                     :value "sample-value"
                                     :path "/cookie"
                                     :max-age 10
                                     :secure false}})]
    (client/await resp)
    (client/string resp)))
</pre>



<p>
    <b>:cookies</b> option takes sequence of cookie maps, in this example
    a hash set.
    Cookie map consist of:
</p><dl>
<dt><b>:domain</b></dt><dd>Domain that cookie has been installed
</dd>
<dt><b>:name</b></dt><dd>Cookie name
</dd>
<dt><b>:value</b></dt><dd>Cookie value, note that there is no additional
                  processing so you should encode it yourself if
                  needed.
</dd>
<dt><b>:path</b></dt><dd>Path on with cookie has been installed
</dd>
<dt><b>:max-age</b></dt><dd>Max age that cookie was configured to live
</dd>
<dt><b>:secure</b></dt><dd>If cookie is secure cookie
</dd>
</dl>


<p>
    Cookie reading is described in <a href="#sec-2-5-4">Reading cookies</a>.
</p></div>

</div>

<div id="outline-container-2-3-5" class="outline-4">
<h4 id="sec-2-3-5"><span class="section-number-4">2.3.5</span> :proxy </h4>
<div class="outline-text-4" id="text-2-3-5">

<p>    Proxy can be configured per request basis as follows:
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp (client/GET client url :proxy {:host h :port p})]
    (client/await resp)
    (client/string resp)))
</pre>



<p>
    Proxy expects a map with following keys:
</p><dl>
<dt><b>:host</b></dt><dd>proxy host
</dd>
<dt><b>:port</b></dt><dd>proxy port
</dd>
<dt><b>:protocol</b></dt><dd><i>optional</i> protocol to communicate with proxy.
                     Can be <b>:http</b> (default) or <b>:https</b>.
</dd>
<dt><b>:user</b></dt><dd><i>optional</i> user name to use for proxy authentication.
                 Must be provided with :password.
</dd>
<dt><b>:password</b></dt><dd><i>optional</i> password to use for proxy
                     authentication.
                     Must be provided with :user.
</dd>
</dl>

</div>

</div>

<div id="outline-container-2-3-6" class="outline-4">
<h4 id="sec-2-3-6"><span class="section-number-4">2.3.6</span> :auth </h4>
<div class="outline-text-4" id="text-2-3-6">

<p>    Authentication can be configured per request basis.
    For now BASIC and DIGEST methods are supported.
</p>
<p>
    Basic method is default, so you don't have to specify it:
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp (client/GET client url :auth {:user u :password p})]
    ;; Check if response is not 401 or so and process response
    ))
</pre>



<p>
    Though you can:
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp (client/GET client url :auth {:type :basic :user u :password p})]
    ;; Check if response is not 401 or so and process response
    ))
</pre>



<p>
    And for digest method you will need realm as well:
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp (client/GET client url
                         :auth {:type :digest :user u :password p :realm r})]
    ;; Check if response is not 401 or so and process response
    ))
</pre>



<p>
    Controlling preemptive authentication behavior is also possible:
</p>


<pre class="example">(with-open [client (client/create-client)]
  (let [resp (client/GET client url :auth {:user u :password p :preemptive true})]
    ;; process response
    ))
</pre>



</div>

</div>

<div id="outline-container-2-3-7" class="outline-4">
<h4 id="sec-2-3-7"><span class="section-number-4">2.3.7</span> :timeout </h4>
<div class="outline-text-4" id="text-2-3-7">

<p>    Response timeout can be configured per request as well.
    Timeout value is time in milliseconds in which response has to be
    received.
    There is special value <b>-1</b> that indicates infinite timeout.
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp (client/GET client url :timeout -1)]
    (client/await resp)
    ;; process response
    ))
</pre>



<p>
    Sample above will wait until response is fully received, as long
    as it takes (-1 timeout).
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp (client/GET client url :timeout 100)]
    (client/await resp)
    (if (client/failed? resp)
      ;; did not get response in configured timeout
      ;; process response
      )))
</pre>



<p>
    Example above configures timeout to 100ms, so <b>await</b> will only
    wait for 100ms, after that response is done.
    Which doesn't necessarily mean that it was delivered to client
    successfully, because it was restricted by timeout, that is why
    example contains check if response has failed.
</p></div>
</div>

</div>

<div id="outline-container-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> Streaming </h3>
<div class="outline-text-3" id="text-2-4">

<p>   HTTP Stream is response with chunked content encoding.
   Those streams might not be meant to ever finish, see twitter.com
   streams, so collecting those responses as a whole is impossible,
   they should be processed by response parts (chunks) as they are
   been received.
</p>
<p>
   Two ways of consuming a HTTP Stream are supported:
</p><ul>
<li><a href="#sec-2-4-1">Lazy sequence</a>
</li>
<li><a href="#sec-2-4-2">Call-back</a>
</li>
</ul>


</div>

<div id="outline-container-2-4-1" class="outline-4">
<h4 id="sec-2-4-1"><span class="section-number-4">2.4.1</span> Lazy sequence </h4>
<div class="outline-text-4" id="text-2-4-1">

<p>    You can get HTTP Stream as lazy sequence of it's body.
    This is very convenient method as <b>seq</b> is native type of Clojure
    so you can apply all mapping, filtering and any other standard
    function that you like to it.
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp (client/stream-seq client :get url)]
    (doseq [s (s/string resp)]
      (println s))))
</pre>



<p>
    <b>stream-seq</b> arguments:
</p><dl>
<dt>http method</dt><dd>any of supported methods can be used, though it
                     makes sense only to use <b>:get</b>, <b>:put</b> and
                     <b>:post</b>
</dd>
<dt>url</dt><dd>URL of HTTP resource
</dd>
<dt>options</dt><dd>same as normal <a href="#sec-2-3">Request options</a>.
</dd>
</dl>


<p>
    It is important to understand that seqs returned by <b>body</b> or
    <b>string</b> (which in turn calls body) are backed by queue.
    One of consequences of it is that once you consumed some body
    parts they will not be available anymore.
    Let's see code speak for itself.
</p>


<pre class="example">(let [resp (client/stream-seq :get url)]
  (println "1: " (first (client/string resp)))
  (println "2: " (first (client/string resp))))
</pre>



<p>
    This code will print following:
</p><pre class="example">
1: part1
2: part2
</pre>

<p>    Assuming that part1 is first chunk and part2 is second.
</p>
<p>
    Second consequence of been directly backed by queue is that you
    can have multiple consumers of same response and non of them will
    get same body part.
</p>
<p>
    And finally this implementation is not holding to it's head.
</p></div>

</div>

<div id="outline-container-2-4-2" class="outline-4">
<h4 id="sec-2-4-2"><span class="section-number-4">2.4.2</span> Call-back </h4>
<div class="outline-text-4" id="text-2-4-2">

<p>    Consuming HTTP Stream with call-back is quite straight forward with
    <b>http.async.client</b>. You will need to know what HTTP Method you will call,
    what URL and provide a call back function to handle body parts been
    received.
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [parts (ref #{})
        resp (client/request-stream client :get url
                                    (fn [state body]
                                      (dosync (alter parts conj (string body)))
                                      [body :continue]))]
    ;; do something to @parts
    ))
</pre>




<p>
    Few notes on implementing body part callback:
</p><ul>
<li>state is a <b>map</b> with <b>:status</b> and <b>:headers</b> as promises, at
   stage when you get called for body part, both of them should be in
   place already, though it is advised to use convenience methods to
   read them, see <a href="#sec-2-5-2">Reading status line</a> and <a href="#sec-2-5-3">Reading headers</a>,
</li>
<li>call-back has to follow guidelines described in <a href="#sec-3-2-3">Body part</a>,
</li>
<li>some streams are not meant to be finished, in that case don't
   collect body parts, as for sure you will run out of available
   resources,
</li>
<li>try not to do any heavy lifting in this callback, better send it
   to agent.
</li>
</ul>

</div>
</div>

</div>

<div id="outline-container-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> Response handling </h3>
<div class="outline-text-3" id="text-2-5">

<p>   <b>http.async.client</b> exposes some convenience functions for
   response handling.
</p>
</div>

<div id="outline-container-2-5-1" class="outline-4">
<h4 id="sec-2-5-1"><span class="section-number-4">2.5.1</span> Awaiting response </h4>
<div class="outline-text-4" id="text-2-5-1">

<p>    If you call any of <a href="#sec-2-1-1">Asynchronous operations</a>, <a href="#sec-2-1-2">Streaming</a> or <a href="#sec-2-1-3">Raw mode</a>
    you actually asynchronously execute HTTP request.
    Some times you might need to wait for response processing to be
    done before proceeding, in order to do so you call
    <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-await"><b>http.async.client/await</b></a>.
    It takes only one argument, that is response and returns once
    receiving has finished.
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp (client/GET client url)]
    (client/await resp)))
</pre>



<p>
    Sample above will behave like synchronous HTTP operation.
    For convenience it returns same response so you can use it
    further, for example like that:
</p>


<pre class="example">(with-open [client (client/create-client)] ;; Create client
  (let [resp (client/GET client url)]
    (client/string (client/await resp))))
</pre>



</div>

</div>

<div id="outline-container-2-5-2" class="outline-4">
<h4 id="sec-2-5-2"><span class="section-number-4">2.5.2</span> Reading status line </h4>
<div class="outline-text-4" id="text-2-5-2">

<p>    <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-status"><b>http.async.client/status</b></a> returns status lazy map of response.
    It will wait until HTTP Status has been received.
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp   (client/GET client url)
        status (client/status resp)]
    (:code status)))
</pre>



<p>
    Sample above will return HTTP response status code, notice that
    after this returns headers and body, might not been delivered
    yet.
</p></div>

</div>

<div id="outline-container-2-5-3" class="outline-4">
<h4 id="sec-2-5-3"><span class="section-number-4">2.5.3</span> Reading headers </h4>
<div class="outline-text-4" id="text-2-5-3">

<p>    <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-headers"><b>http.async.client/headers</b></a> returns headers lazy map of response.
    It will wait until HTTP Headers are received.
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp    (client/GET client url)
        headers (client/headers resp)]
    (:server headers)))
</pre>



<p>
    Again, like in case of status, body might not have been delivered
    yet after this returns.
</p></div>

</div>

<div id="outline-container-2-5-4" class="outline-4">
<h4 id="sec-2-5-4"><span class="section-number-4">2.5.4</span> Reading cookies </h4>
<div class="outline-text-4" id="text-2-5-4">

<p>    <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-cookies"><b>http.async.client/cookies</b></a> returns seq of maps representing
    cookies.
    It will wait until HTTP Headers are received.
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp    (client/GET client url)
        cookies (client/cookies resp)]
    (map :name cookies)))
</pre>



<p>
    Sample above will return sequence of cookie names that server has
    set.
</p></div>

</div>

<div id="outline-container-2-5-5" class="outline-4">
<h4 id="sec-2-5-5"><span class="section-number-4">2.5.5</span> Reading body </h4>
<div class="outline-text-4" id="text-2-5-5">

<p>    <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-body"><b>http.async.client/body</b></a> returns either ByteArrayOutputStream or
    seq of it, depending if you used <a href="#sec-2-1-1">Asynchronous operations</a> or
    <a href="#sec-2-1-2">Streaming</a> respectively.
    It will <b>not</b> wait for response to be finished, it will return as
    soon as first chunk of HTTP response body is received.
</p></div>

</div>

<div id="outline-container-2-5-6" class="outline-4">
<h4 id="sec-2-5-6"><span class="section-number-4">2.5.6</span> Reading body as string </h4>
<div class="outline-text-4" id="text-2-5-6">

<p>    <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-string"><b>http.async.client/string</b></a> returns either string or seq of
    strings, again depending if you used <a href="#sec-2-1-1">Asynchronous operations</a> or
    <a href="#sec-2-1-2">Streaming</a> respectively.
    It will <b>not</b> wait for response to be finished, it will return as
    soon as first chunk of HTTP response body is received.
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp (client/GET client url)]
    (client/string (client/await resp))))
</pre>



<p>
    Sample above will return string of response body.
    <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-string"><b>http.async.client/string</b></a> is lazy so you can use it in case of
    streams as well.
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp    (client/stream-seq client :get url)
        strings (client/string resp)]
    (doseq [part strings]
      (println part))))
</pre>



<p>
    Sample above will print parts as they are received, and will
    return once response receiving is finished.
</p></div>

</div>

<div id="outline-container-2-5-7" class="outline-4">
<h4 id="sec-2-5-7"><span class="section-number-4">2.5.7</span> Reading error </h4>
<div class="outline-text-4" id="text-2-5-7">

<p>    <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-error"><b>http.async.client/error</b></a> will return Throwable that was cause of
    request failure iff request failed, else <b>nil</b>.
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp (client/GET client url)]
    (client/await resp)
    (when-let [err (client/error resp)]
      (println "failed processing request: " err))))
</pre>



</div>

</div>

<div id="outline-container-2-5-8" class="outline-4">
<h4 id="sec-2-5-8"><span class="section-number-4">2.5.8</span> Canceling request </h4>
<div class="outline-text-4" id="text-2-5-8">

<p>    At any given time of processing HTTP Response you can <b>cancel</b> it
    by calling <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-cancel"><b>http.async.client/cancel</b></a>.
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp (client/GET client url)]
    (client/cancel resp)))
</pre>



<p>
    Please see <b>canceling-request</b> test.
</p></div>

</div>

<div id="outline-container-2-5-9" class="outline-4">
<h4 id="sec-2-5-9"><span class="section-number-4">2.5.9</span> Response predicates </h4>
<div class="outline-text-4" id="text-2-5-9">

<p>    You can also check status of request.
</p>
</div>

<div id="outline-container-2-5-9-1" class="outline-5">
<h5 id="sec-2-5-9-1"><span class="section-number-5">2.5.9.1</span> done? </h5>
<div class="outline-text-5" id="text-2-5-9-1">

<p>     <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-done?"><b>http.async.client/done?</b></a> will tell you if response processing
     has finished:
</p>


<pre class="example">(with-open [client (client/create-client)] ; Create client
  (let [resp (client/GET client url)]
    (when-not (client/done? resp)
      (client/await resp)
      (client/done? resp))))
</pre>



<p>
     Sample above will check if response was finished, if not - will
     wait for it and return true as a result of call to done?.
</p></div>

</div>

<div id="outline-container-2-5-9-2" class="outline-5">
<h5 id="sec-2-5-9-2"><span class="section-number-5">2.5.9.2</span> failed? </h5>
<div class="outline-text-5" id="text-2-5-9-2">

<p>     <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-failed?"><b>http.async.client/failed?</b></a> will return true iff request has
     failed. If this return true you can <a href="#sec-2-5-7">read error</a>.
</p></div>

</div>

<div id="outline-container-2-5-9-3" class="outline-5">
<h5 id="sec-2-5-9-3"><span class="section-number-5">2.5.9.3</span> canceled? </h5>
<div class="outline-text-5" id="text-2-5-9-3">

<p>     <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-canceled?"><b>http.async.client/canceled?</b></a> will return true iff request has
     been <a href="#sec-2-5-8">canceled</a>, else false is return.
</p></div>
</div>
</div>

</div>

<div id="outline-container-2-6" class="outline-3">
<h3 id="sec-2-6"><span class="section-number-3">2.6</span> Managing client </h3>
<div class="outline-text-3" id="text-2-6">


</div>

<div id="outline-container-2-6-1" class="outline-4">
<h4 id="sec-2-6-1"><span class="section-number-4">2.6.1</span> Branding </h4>
<div class="outline-text-4" id="text-2-6-1">

<p>    <b>http.async.client</b> can be configured with User-Agent. To do so
    you can use <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-create-client"><b>http.async.client/create-client</b></a> and remember to
    close created client yourself, best is to use it within macro
    like with-open, though make sure that body of it will wait for
    whore response to finish.
</p>


<pre class="example">(with-open [client (client/create-client {:user-agent "Your User Agent/1.0"})]
  (let [resp (client/GET client url)]
    ;; do stuff with resp
    ))
</pre>



</div>

</div>

<div id="outline-container-2-6-2" class="outline-4">
<h4 id="sec-2-6-2"><span class="section-number-4">2.6.2</span> Enabling HTTP compression </h4>
<div class="outline-text-4" id="text-2-6-2">

<p>    <b>http.async.client</b> can be configured to allow, or not, HTTP
    compression.
</p>


<pre class="example">(with-open [client (client/create-client {:compression-enabled true})]
  (let [resp (client/GET client url)]
    ;; do stuff with resp
    ))
</pre>



</div>

</div>

<div id="outline-container-2-6-3" class="outline-4">
<h4 id="sec-2-6-3"><span class="section-number-4">2.6.3</span> Follow redirects </h4>
<div class="outline-text-4" id="text-2-6-3">

<p>    Enabling HTTP redirects following.
</p>


<pre class="example">(with-open [client  (client/create-client {:follow-redirects true})]
  (let [resp (client/GET client url)]
    ;; do stuff with resp
    ))
</pre>



</div>

</div>

<div id="outline-container-2-6-4" class="outline-4">
<h4 id="sec-2-6-4"><span class="section-number-4">2.6.4</span> Keep alive </h4>
<div class="outline-text-4" id="text-2-6-4">

<p>    Keep Alive is enabled by default. This implies using pool for
    connections.
</p>


<pre class="example">(with-open [client (client/create-client {:keep-alive true})]
  (let [resp (client/GET client url)]
    ;; do stuff with resp
    ))
</pre>



</div>

</div>

<div id="outline-container-2-6-5" class="outline-4">
<h4 id="sec-2-6-5"><span class="section-number-4">2.6.5</span> Max connections per host </h4>
<div class="outline-text-4" id="text-2-6-5">

<p>    Maximum number of connections to be cached per host.
    Above this number connections will still be created but will not
    be kept alive.
</p>


<pre class="example">(with-open [client (client/create-client {:max-conns-per-host 10})]
  (let [resp (client/GET client url)]
    ;; do stuff with resp
    ))
</pre>



</div>

</div>

<div id="outline-container-2-6-6" class="outline-4">
<h4 id="sec-2-6-6"><span class="section-number-4">2.6.6</span> Max connections total count </h4>
<div class="outline-text-4" id="text-2-6-6">

<p>    Maximum number of total connections opened, submitting new
    request while all allowed connections are active, will result in
    rejection.
</p>


<pre class="example">(with-open [client (client/create-client {:max-conns-total 100})]
  (let [resp (client/GET client url)]
    ;; do stuff with resp
    ))
</pre>



</div>

</div>

<div id="outline-container-2-6-7" class="outline-4">
<h4 id="sec-2-6-7"><span class="section-number-4">2.6.7</span> Max redirects to follow </h4>
<div class="outline-text-4" id="text-2-6-7">

<p>    Maximum number of redirects to follow.
</p>


<pre class="example">(with-open [client (client/create-client {:max-redirects 3})]
  (let [resp (client/GET client url)]
    ;; do stuff with resp
    ))
</pre>



</div>

</div>

<div id="outline-container-2-6-8" class="outline-4">
<h4 id="sec-2-6-8"><span class="section-number-4">2.6.8</span> Timeouts </h4>
<div class="outline-text-4" id="text-2-6-8">

<p>    With <b>http.async.client</b> apart from per connection <a href="#sec-2-3-7">:timeout</a> you
    can globally configure <b>connection</b>, <b>request</b> and <b>idle</b>
    timeouts. All timeout values are in milliseconds and magic value
    <b>-1</b> is interpreted as infinite wait.
    <b>idle</b> connection in pool timeout works only on connections in
    pool, connections idle, for configured time, in pool will be
    closed.
</p>


<pre class="example">(with-open [client (client/create-client {:connection-timeout 10
                                          :request-timeout 1000
                                          :idle-in-pool-timeout 100})]
  (let [resp (client/client client/GET url)]
    ;; request processing
    ))
</pre>



<p>
    Example above will timeout connection if it was not established
    in 10ms, request if it was not received in 1sec, or connection
    when it was idling in pool for more than 100ms.
</p></div>

</div>

<div id="outline-container-2-6-9" class="outline-4">
<h4 id="sec-2-6-9"><span class="section-number-4">2.6.9</span> Proxy </h4>
<div class="outline-text-4" id="text-2-6-9">

<p>    Client can be also configured with global HTTP Proxy settings.
</p>


<pre class="example">(with-open [client (client/create-client {:proxy {:host h :port p}})]
  (let [resp (client/GET client url)]
    ;; do stuff with resp
    ))
</pre>



<p>
    Proxy expects a map with following keys:
</p><dl>
<dt><b>:host</b></dt><dd>proxy host
</dd>
<dt><b>:port</b></dt><dd>proxy port
</dd>
<dt><b>:protocol</b></dt><dd><i>optional</i> protocol to communicate with proxy.
                     Can be <b>:http</b> (default) or <b>:https</b>.
</dd>
<dt><b>:user</b></dt><dd><i>optional</i> user name to use for proxy authentication.
                 Must be provided with :password.
</dd>
<dt><b>:password</b></dt><dd><i>optional</i> password to use for proxy
                     authentication.
                     Must be provided with :user.
</dd>
</dl>

</div>

</div>

<div id="outline-container-2-6-10" class="outline-4">
<h4 id="sec-2-6-10"><span class="section-number-4">2.6.10</span> Authentication </h4>
<div class="outline-text-4" id="text-2-6-10">

<p>    Default authentication realm to be used globally can be
    configured.
    For now BASIC and DIGEST methods are supported.
</p>
<p>
    Basic method is default, so you don't have to specify it:
</p>


<pre class="example">(with-open [client (client/create-client {:auth {:user u :password p}})] 
  (let [resp (client/GET client url)]
    ;; Check if response is not 401 or so and process response
    ))
</pre>



<p>
    Though you can:
</p>


<pre class="example">(with-open [client (client/create-client :auth {:type :basic :user u :password p})]
  (let [resp (client/GET client url)]
    ;; Check if response is not 401 or so and process response
    ))
</pre>



<p>
    And for digest method you will need realm as well:
</p>


<pre class="example">(with-open [client (client/create-client :auth {:type :digest :user u :password p :realm r})]
  (let [resp (client/GET client url)]
    ;; Check if response is not 401 or so and process response
    ))
</pre>



<p>
    Preemptive authentication can be enabled or disabled globally per client:
</p>


<pre class="example">(with-open [client (client/create-client :auth {:type :basic :user u :passowrd p :preemptive true})]
  (let [resp (client/GET client url)]
    ;; process response
    ))
</pre>



</div>

</div>

<div id="outline-container-2-6-11" class="outline-4">
<h4 id="sec-2-6-11"><span class="section-number-4">2.6.11</span> Closing <b>http.async.client</b> </h4>
<div class="outline-text-4" id="text-2-6-11">

<p>    Whenever you've created <b>http.async.client</b> via
    <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-create-client"><b>http.async.client/create-client</b></a> you will need to close it.
    To do so you call <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-close"><b>http.async.client/close</b></a>.
</p>


<pre class="example">(let [client (client/create-client)]
  (try
    (let [resp (client/GET client url)]
      ;; process response
      )
    (finally
     (client/close client))))
</pre>



</div>
</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Low level </h2>
<div class="outline-text-2" id="text-3">

<p>  This is lowest level access to <b>http.async.client</b>.
  Mechanics here is based on asynchronous call-backs.
  It provides default set of callbacks and functions to create and
  execute requests.
</p>
</div>

<div id="outline-container-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Preparing request </h3>
<div class="outline-text-3" id="text-3-1">

<p>   <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.request.html#var-prepare-request"><b>http.async.client.request/prepare-request</b></a> is responsible for
   request preparation, like name suggests.
   It takes following arguments:
</p><ul>
<li>HTTP Method like <b>:get</b> <b>:head</b>
</li>
<li><b>url</b> that you want to call
</li>
<li>and <b>options</b>, a keyworded map described already in <a href="#sec-2-3">Request options</a>.
    Sample:



<pre class="example">(with-open [client (client/create-client)]
  (let [req (prepare-request client
             :get "http://google.com"
             :headers {:my-header "value"})]
    ;; now you have request, next thing to do would be to execute it
    ))
</pre>



</li>
</ul>

</div>

</div>

<div id="outline-container-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Executing request </h3>
<div class="outline-text-3" id="text-3-2">

<p>   <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.request.html#var-execute-request"><b>http.async.client.request/execute-request</b></a> returns same map of promises
   as <a href="#sec-2-1-1">Asynchronous operations</a>.
   Its arguments are: request to be executed (result of <a href="#sec-3-1">Preparing request</a>) and <b>options</b> as keyworded map consisting of call-backs.
   Following <b>options</b> are recognized:
</p><dl>
<dt><b>:status</b></dt><dd><a href="#sec-3-2-1">Status line</a>
</dd>
<dt><b>:headers</b></dt><dd><a href="#sec-3-2-2">Headers</a>
</dd>
<dt><b>:part</b></dt><dd><a href="#sec-3-2-3">Body part</a>
</dd>
<dt><b>:completed</b></dt><dd><a href="#sec-3-2-4">Body completed</a>
</dd>
<dt><b>:error</b></dt><dd><a href="#sec-3-2-5">Error</a>
</dd>
</dl>

<p>   All callbacks take response map as first argument and callback
   specific argument if any.
   Callbacks are expected to return tuple of <b>result</b> and <b>action</b>:
</p><dl>
<dt><b>result</b></dt><dd>will be delivered to respective promise in response
                 map
</dd>
<dt><b>action</b></dt><dd>if its value is <b>:abort</b> than response processing
                 will be aborted, anything else here will result in
                 continuation.
</dd>
</dl>


</div>

<div id="outline-container-3-2-1" class="outline-4">
<h4 id="sec-3-2-1"><span class="section-number-4">3.2.1</span> Status line </h4>
<div class="outline-text-4" id="text-3-2-1">

<p>    Status line callback gets called after status line has been
    received with arguments:
</p><ul>
<li>response map
</li>
<li>Status map has following keys:
<ul>
<li><b>:code</b> status code (200, 404, ..)
</li>
<li><b>:msg</b> status message ("OK", ..)
</li>
<li><b>:protocol</b> protocol with version ("HTTP/1.1")
</li>
<li><b>:major</b> major protocol version (1)
</li>
<li><b>:minor</b> minor protocol version (0, 1)
</li>
</ul>

</li>
</ul>

</div>

</div>

<div id="outline-container-3-2-2" class="outline-4">
<h4 id="sec-3-2-2"><span class="section-number-4">3.2.2</span> Headers </h4>
<div class="outline-text-4" id="text-3-2-2">

<p>    Headers callback gets called after headers have been received
    with arguments:
</p><ul>
<li>response map
</li>
<li>lazy map of headers. Keys in that map are <b>(keyword       (.toLowerCase &lt;header name&gt;))</b>, so "Server" headers is
      <b>:server</b> and so on.
</li>
</ul>

</div>

</div>

<div id="outline-container-3-2-3" class="outline-4">
<h4 id="sec-3-2-3"><span class="section-number-4">3.2.3</span> Body part </h4>
<div class="outline-text-4" id="text-3-2-3">

<p>    Body part callback gets called after each part of body has been
    received with arguments:
</p><ul>
<li>response map
</li>
<li>ByteArrayOutputStream that contains body part received.
</li>
</ul>

</div>

</div>

<div id="outline-container-3-2-4" class="outline-4">
<h4 id="sec-3-2-4"><span class="section-number-4">3.2.4</span> Body completed </h4>
<div class="outline-text-4" id="text-3-2-4">

<p>    This callback gets called when receiving of response body has
    finished with only one argument, i.e. response map.
</p></div>

</div>

<div id="outline-container-3-2-5" class="outline-4">
<h4 id="sec-3-2-5"><span class="section-number-4">3.2.5</span> Error </h4>
<div class="outline-text-4" id="text-3-2-5">

<p>    Error callback gets called when error while processing has been
    encountered with arguments
</p><ul>
<li>response map
</li>
<li><b>Throwable</b> that was a cause of failure
</li>
</ul>

</div>
</div>

</div>

<div id="outline-container-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Default callbacks </h3>
<div class="outline-text-3" id="text-3-3">

<p>   <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.request.html#var-*default-callbacks*"><b>http.async.client.request/*default-callbacks*</b></a> is a map of
   default callbacks. This fill allow you to easy change only few
   callbacks and reuse default for the rest.
</p>
<p>
   Please look at source of <a href="http://neotyk.github.com/http.async.client/doc/http.async.client.html#var-stream-seq"><b>http.async.client/stream-seq</b></a> to see
   how to do it.
</p>


<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-28022940-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</div>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2012-02-05 16:38:43 CET</p>
<p class="author">Author: Hubert Iwaniuk</p>
<p class="creator">Org version 7.7 with Emacs version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
